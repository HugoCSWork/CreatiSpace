// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'payment_setup_value_failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$PaymentSetupValueFailuresTearOff {
  const _$PaymentSetupValueFailuresTearOff();

// ignore: unused_element
  EmptyField<T> emptyField<T>({@required String failedValue}) {
    return EmptyField<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidEmail<T> invalidEmail<T>({@required String failedValue}) {
    return InvalidEmail<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidFirstName<T> invalidFirstName<T>({@required String failedValue}) {
    return InvalidFirstName<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidLastName<T> invalidLastName<T>({@required String failedValue}) {
    return InvalidLastName<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidDob<T> invalidDob<T>({@required String failedValue}) {
    return InvalidDob<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidPhoneNumber<T> invalidPhoneNumber<T>({@required String failedValue}) {
    return InvalidPhoneNumber<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidGender<T> invalidGender<T>({@required String failedValue}) {
    return InvalidGender<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidAccountName<T> invalidAccountName<T>({@required String failedValue}) {
    return InvalidAccountName<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidAccountNumber<T> invalidAccountNumber<T>(
      {@required String failedValue}) {
    return InvalidAccountNumber<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidSortCode<T> invalidSortCode<T>({@required String failedValue}) {
    return InvalidSortCode<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  UncheckedTermsAndService<T> uncheckedTermsAndService<T>(
      {@required bool failedValue}) {
    return UncheckedTermsAndService<T>(
      failedValue: failedValue,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $PaymentSetupValueFailures = _$PaymentSetupValueFailuresTearOff();

/// @nodoc
mixin _$PaymentSetupValueFailures<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String failedValue),
    @required TResult invalidEmail(String failedValue),
    @required TResult invalidFirstName(String failedValue),
    @required TResult invalidLastName(String failedValue),
    @required TResult invalidDob(String failedValue),
    @required TResult invalidPhoneNumber(String failedValue),
    @required TResult invalidGender(String failedValue),
    @required TResult invalidAccountName(String failedValue),
    @required TResult invalidAccountNumber(String failedValue),
    @required TResult invalidSortCode(String failedValue),
    @required TResult uncheckedTermsAndService(bool failedValue),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String failedValue),
    TResult invalidEmail(String failedValue),
    TResult invalidFirstName(String failedValue),
    TResult invalidLastName(String failedValue),
    TResult invalidDob(String failedValue),
    TResult invalidPhoneNumber(String failedValue),
    TResult invalidGender(String failedValue),
    TResult invalidAccountName(String failedValue),
    TResult invalidAccountNumber(String failedValue),
    TResult invalidSortCode(String failedValue),
    TResult uncheckedTermsAndService(bool failedValue),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(EmptyField<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult invalidFirstName(InvalidFirstName<T> value),
    @required TResult invalidLastName(InvalidLastName<T> value),
    @required TResult invalidDob(InvalidDob<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidGender(InvalidGender<T> value),
    @required TResult invalidAccountName(InvalidAccountName<T> value),
    @required TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    @required TResult invalidSortCode(InvalidSortCode<T> value),
    @required
        TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(EmptyField<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult invalidFirstName(InvalidFirstName<T> value),
    TResult invalidLastName(InvalidLastName<T> value),
    TResult invalidDob(InvalidDob<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidGender(InvalidGender<T> value),
    TResult invalidAccountName(InvalidAccountName<T> value),
    TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    TResult invalidSortCode(InvalidSortCode<T> value),
    TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $PaymentSetupValueFailuresCopyWith<T, $Res> {
  factory $PaymentSetupValueFailuresCopyWith(PaymentSetupValueFailures<T> value,
          $Res Function(PaymentSetupValueFailures<T>) then) =
      _$PaymentSetupValueFailuresCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$PaymentSetupValueFailuresCopyWithImpl<T, $Res>
    implements $PaymentSetupValueFailuresCopyWith<T, $Res> {
  _$PaymentSetupValueFailuresCopyWithImpl(this._value, this._then);

  final PaymentSetupValueFailures<T> _value;
  // ignore: unused_field
  final $Res Function(PaymentSetupValueFailures<T>) _then;
}

/// @nodoc
abstract class $EmptyFieldCopyWith<T, $Res> {
  factory $EmptyFieldCopyWith(
          EmptyField<T> value, $Res Function(EmptyField<T>) then) =
      _$EmptyFieldCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$EmptyFieldCopyWithImpl<T, $Res>
    extends _$PaymentSetupValueFailuresCopyWithImpl<T, $Res>
    implements $EmptyFieldCopyWith<T, $Res> {
  _$EmptyFieldCopyWithImpl(
      EmptyField<T> _value, $Res Function(EmptyField<T>) _then)
      : super(_value, (v) => _then(v as EmptyField<T>));

  @override
  EmptyField<T> get _value => super._value as EmptyField<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(EmptyField<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as String,
    ));
  }
}

/// @nodoc
class _$EmptyField<T> implements EmptyField<T> {
  const _$EmptyField({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final String failedValue;

  @override
  String toString() {
    return 'PaymentSetupValueFailures<$T>.emptyField(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmptyField<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $EmptyFieldCopyWith<T, EmptyField<T>> get copyWith =>
      _$EmptyFieldCopyWithImpl<T, EmptyField<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String failedValue),
    @required TResult invalidEmail(String failedValue),
    @required TResult invalidFirstName(String failedValue),
    @required TResult invalidLastName(String failedValue),
    @required TResult invalidDob(String failedValue),
    @required TResult invalidPhoneNumber(String failedValue),
    @required TResult invalidGender(String failedValue),
    @required TResult invalidAccountName(String failedValue),
    @required TResult invalidAccountNumber(String failedValue),
    @required TResult invalidSortCode(String failedValue),
    @required TResult uncheckedTermsAndService(bool failedValue),
  }) {
    assert(emptyField != null);
    assert(invalidEmail != null);
    assert(invalidFirstName != null);
    assert(invalidLastName != null);
    assert(invalidDob != null);
    assert(invalidPhoneNumber != null);
    assert(invalidGender != null);
    assert(invalidAccountName != null);
    assert(invalidAccountNumber != null);
    assert(invalidSortCode != null);
    assert(uncheckedTermsAndService != null);
    return emptyField(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String failedValue),
    TResult invalidEmail(String failedValue),
    TResult invalidFirstName(String failedValue),
    TResult invalidLastName(String failedValue),
    TResult invalidDob(String failedValue),
    TResult invalidPhoneNumber(String failedValue),
    TResult invalidGender(String failedValue),
    TResult invalidAccountName(String failedValue),
    TResult invalidAccountNumber(String failedValue),
    TResult invalidSortCode(String failedValue),
    TResult uncheckedTermsAndService(bool failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (emptyField != null) {
      return emptyField(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(EmptyField<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult invalidFirstName(InvalidFirstName<T> value),
    @required TResult invalidLastName(InvalidLastName<T> value),
    @required TResult invalidDob(InvalidDob<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidGender(InvalidGender<T> value),
    @required TResult invalidAccountName(InvalidAccountName<T> value),
    @required TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    @required TResult invalidSortCode(InvalidSortCode<T> value),
    @required
        TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
  }) {
    assert(emptyField != null);
    assert(invalidEmail != null);
    assert(invalidFirstName != null);
    assert(invalidLastName != null);
    assert(invalidDob != null);
    assert(invalidPhoneNumber != null);
    assert(invalidGender != null);
    assert(invalidAccountName != null);
    assert(invalidAccountNumber != null);
    assert(invalidSortCode != null);
    assert(uncheckedTermsAndService != null);
    return emptyField(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(EmptyField<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult invalidFirstName(InvalidFirstName<T> value),
    TResult invalidLastName(InvalidLastName<T> value),
    TResult invalidDob(InvalidDob<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidGender(InvalidGender<T> value),
    TResult invalidAccountName(InvalidAccountName<T> value),
    TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    TResult invalidSortCode(InvalidSortCode<T> value),
    TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (emptyField != null) {
      return emptyField(this);
    }
    return orElse();
  }
}

abstract class EmptyField<T> implements PaymentSetupValueFailures<T> {
  const factory EmptyField({@required String failedValue}) = _$EmptyField<T>;

  String get failedValue;
  @JsonKey(ignore: true)
  $EmptyFieldCopyWith<T, EmptyField<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidEmailCopyWith<T, $Res> {
  factory $InvalidEmailCopyWith(
          InvalidEmail<T> value, $Res Function(InvalidEmail<T>) then) =
      _$InvalidEmailCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$InvalidEmailCopyWithImpl<T, $Res>
    extends _$PaymentSetupValueFailuresCopyWithImpl<T, $Res>
    implements $InvalidEmailCopyWith<T, $Res> {
  _$InvalidEmailCopyWithImpl(
      InvalidEmail<T> _value, $Res Function(InvalidEmail<T>) _then)
      : super(_value, (v) => _then(v as InvalidEmail<T>));

  @override
  InvalidEmail<T> get _value => super._value as InvalidEmail<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidEmail<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as String,
    ));
  }
}

/// @nodoc
class _$InvalidEmail<T> implements InvalidEmail<T> {
  const _$InvalidEmail({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final String failedValue;

  @override
  String toString() {
    return 'PaymentSetupValueFailures<$T>.invalidEmail(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidEmail<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $InvalidEmailCopyWith<T, InvalidEmail<T>> get copyWith =>
      _$InvalidEmailCopyWithImpl<T, InvalidEmail<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String failedValue),
    @required TResult invalidEmail(String failedValue),
    @required TResult invalidFirstName(String failedValue),
    @required TResult invalidLastName(String failedValue),
    @required TResult invalidDob(String failedValue),
    @required TResult invalidPhoneNumber(String failedValue),
    @required TResult invalidGender(String failedValue),
    @required TResult invalidAccountName(String failedValue),
    @required TResult invalidAccountNumber(String failedValue),
    @required TResult invalidSortCode(String failedValue),
    @required TResult uncheckedTermsAndService(bool failedValue),
  }) {
    assert(emptyField != null);
    assert(invalidEmail != null);
    assert(invalidFirstName != null);
    assert(invalidLastName != null);
    assert(invalidDob != null);
    assert(invalidPhoneNumber != null);
    assert(invalidGender != null);
    assert(invalidAccountName != null);
    assert(invalidAccountNumber != null);
    assert(invalidSortCode != null);
    assert(uncheckedTermsAndService != null);
    return invalidEmail(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String failedValue),
    TResult invalidEmail(String failedValue),
    TResult invalidFirstName(String failedValue),
    TResult invalidLastName(String failedValue),
    TResult invalidDob(String failedValue),
    TResult invalidPhoneNumber(String failedValue),
    TResult invalidGender(String failedValue),
    TResult invalidAccountName(String failedValue),
    TResult invalidAccountNumber(String failedValue),
    TResult invalidSortCode(String failedValue),
    TResult uncheckedTermsAndService(bool failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmail != null) {
      return invalidEmail(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(EmptyField<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult invalidFirstName(InvalidFirstName<T> value),
    @required TResult invalidLastName(InvalidLastName<T> value),
    @required TResult invalidDob(InvalidDob<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidGender(InvalidGender<T> value),
    @required TResult invalidAccountName(InvalidAccountName<T> value),
    @required TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    @required TResult invalidSortCode(InvalidSortCode<T> value),
    @required
        TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
  }) {
    assert(emptyField != null);
    assert(invalidEmail != null);
    assert(invalidFirstName != null);
    assert(invalidLastName != null);
    assert(invalidDob != null);
    assert(invalidPhoneNumber != null);
    assert(invalidGender != null);
    assert(invalidAccountName != null);
    assert(invalidAccountNumber != null);
    assert(invalidSortCode != null);
    assert(uncheckedTermsAndService != null);
    return invalidEmail(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(EmptyField<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult invalidFirstName(InvalidFirstName<T> value),
    TResult invalidLastName(InvalidLastName<T> value),
    TResult invalidDob(InvalidDob<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidGender(InvalidGender<T> value),
    TResult invalidAccountName(InvalidAccountName<T> value),
    TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    TResult invalidSortCode(InvalidSortCode<T> value),
    TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmail != null) {
      return invalidEmail(this);
    }
    return orElse();
  }
}

abstract class InvalidEmail<T> implements PaymentSetupValueFailures<T> {
  const factory InvalidEmail({@required String failedValue}) =
      _$InvalidEmail<T>;

  String get failedValue;
  @JsonKey(ignore: true)
  $InvalidEmailCopyWith<T, InvalidEmail<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidFirstNameCopyWith<T, $Res> {
  factory $InvalidFirstNameCopyWith(
          InvalidFirstName<T> value, $Res Function(InvalidFirstName<T>) then) =
      _$InvalidFirstNameCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$InvalidFirstNameCopyWithImpl<T, $Res>
    extends _$PaymentSetupValueFailuresCopyWithImpl<T, $Res>
    implements $InvalidFirstNameCopyWith<T, $Res> {
  _$InvalidFirstNameCopyWithImpl(
      InvalidFirstName<T> _value, $Res Function(InvalidFirstName<T>) _then)
      : super(_value, (v) => _then(v as InvalidFirstName<T>));

  @override
  InvalidFirstName<T> get _value => super._value as InvalidFirstName<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidFirstName<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as String,
    ));
  }
}

/// @nodoc
class _$InvalidFirstName<T> implements InvalidFirstName<T> {
  const _$InvalidFirstName({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final String failedValue;

  @override
  String toString() {
    return 'PaymentSetupValueFailures<$T>.invalidFirstName(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidFirstName<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $InvalidFirstNameCopyWith<T, InvalidFirstName<T>> get copyWith =>
      _$InvalidFirstNameCopyWithImpl<T, InvalidFirstName<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String failedValue),
    @required TResult invalidEmail(String failedValue),
    @required TResult invalidFirstName(String failedValue),
    @required TResult invalidLastName(String failedValue),
    @required TResult invalidDob(String failedValue),
    @required TResult invalidPhoneNumber(String failedValue),
    @required TResult invalidGender(String failedValue),
    @required TResult invalidAccountName(String failedValue),
    @required TResult invalidAccountNumber(String failedValue),
    @required TResult invalidSortCode(String failedValue),
    @required TResult uncheckedTermsAndService(bool failedValue),
  }) {
    assert(emptyField != null);
    assert(invalidEmail != null);
    assert(invalidFirstName != null);
    assert(invalidLastName != null);
    assert(invalidDob != null);
    assert(invalidPhoneNumber != null);
    assert(invalidGender != null);
    assert(invalidAccountName != null);
    assert(invalidAccountNumber != null);
    assert(invalidSortCode != null);
    assert(uncheckedTermsAndService != null);
    return invalidFirstName(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String failedValue),
    TResult invalidEmail(String failedValue),
    TResult invalidFirstName(String failedValue),
    TResult invalidLastName(String failedValue),
    TResult invalidDob(String failedValue),
    TResult invalidPhoneNumber(String failedValue),
    TResult invalidGender(String failedValue),
    TResult invalidAccountName(String failedValue),
    TResult invalidAccountNumber(String failedValue),
    TResult invalidSortCode(String failedValue),
    TResult uncheckedTermsAndService(bool failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidFirstName != null) {
      return invalidFirstName(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(EmptyField<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult invalidFirstName(InvalidFirstName<T> value),
    @required TResult invalidLastName(InvalidLastName<T> value),
    @required TResult invalidDob(InvalidDob<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidGender(InvalidGender<T> value),
    @required TResult invalidAccountName(InvalidAccountName<T> value),
    @required TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    @required TResult invalidSortCode(InvalidSortCode<T> value),
    @required
        TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
  }) {
    assert(emptyField != null);
    assert(invalidEmail != null);
    assert(invalidFirstName != null);
    assert(invalidLastName != null);
    assert(invalidDob != null);
    assert(invalidPhoneNumber != null);
    assert(invalidGender != null);
    assert(invalidAccountName != null);
    assert(invalidAccountNumber != null);
    assert(invalidSortCode != null);
    assert(uncheckedTermsAndService != null);
    return invalidFirstName(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(EmptyField<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult invalidFirstName(InvalidFirstName<T> value),
    TResult invalidLastName(InvalidLastName<T> value),
    TResult invalidDob(InvalidDob<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidGender(InvalidGender<T> value),
    TResult invalidAccountName(InvalidAccountName<T> value),
    TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    TResult invalidSortCode(InvalidSortCode<T> value),
    TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidFirstName != null) {
      return invalidFirstName(this);
    }
    return orElse();
  }
}

abstract class InvalidFirstName<T> implements PaymentSetupValueFailures<T> {
  const factory InvalidFirstName({@required String failedValue}) =
      _$InvalidFirstName<T>;

  String get failedValue;
  @JsonKey(ignore: true)
  $InvalidFirstNameCopyWith<T, InvalidFirstName<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidLastNameCopyWith<T, $Res> {
  factory $InvalidLastNameCopyWith(
          InvalidLastName<T> value, $Res Function(InvalidLastName<T>) then) =
      _$InvalidLastNameCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$InvalidLastNameCopyWithImpl<T, $Res>
    extends _$PaymentSetupValueFailuresCopyWithImpl<T, $Res>
    implements $InvalidLastNameCopyWith<T, $Res> {
  _$InvalidLastNameCopyWithImpl(
      InvalidLastName<T> _value, $Res Function(InvalidLastName<T>) _then)
      : super(_value, (v) => _then(v as InvalidLastName<T>));

  @override
  InvalidLastName<T> get _value => super._value as InvalidLastName<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidLastName<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as String,
    ));
  }
}

/// @nodoc
class _$InvalidLastName<T> implements InvalidLastName<T> {
  const _$InvalidLastName({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final String failedValue;

  @override
  String toString() {
    return 'PaymentSetupValueFailures<$T>.invalidLastName(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidLastName<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $InvalidLastNameCopyWith<T, InvalidLastName<T>> get copyWith =>
      _$InvalidLastNameCopyWithImpl<T, InvalidLastName<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String failedValue),
    @required TResult invalidEmail(String failedValue),
    @required TResult invalidFirstName(String failedValue),
    @required TResult invalidLastName(String failedValue),
    @required TResult invalidDob(String failedValue),
    @required TResult invalidPhoneNumber(String failedValue),
    @required TResult invalidGender(String failedValue),
    @required TResult invalidAccountName(String failedValue),
    @required TResult invalidAccountNumber(String failedValue),
    @required TResult invalidSortCode(String failedValue),
    @required TResult uncheckedTermsAndService(bool failedValue),
  }) {
    assert(emptyField != null);
    assert(invalidEmail != null);
    assert(invalidFirstName != null);
    assert(invalidLastName != null);
    assert(invalidDob != null);
    assert(invalidPhoneNumber != null);
    assert(invalidGender != null);
    assert(invalidAccountName != null);
    assert(invalidAccountNumber != null);
    assert(invalidSortCode != null);
    assert(uncheckedTermsAndService != null);
    return invalidLastName(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String failedValue),
    TResult invalidEmail(String failedValue),
    TResult invalidFirstName(String failedValue),
    TResult invalidLastName(String failedValue),
    TResult invalidDob(String failedValue),
    TResult invalidPhoneNumber(String failedValue),
    TResult invalidGender(String failedValue),
    TResult invalidAccountName(String failedValue),
    TResult invalidAccountNumber(String failedValue),
    TResult invalidSortCode(String failedValue),
    TResult uncheckedTermsAndService(bool failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidLastName != null) {
      return invalidLastName(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(EmptyField<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult invalidFirstName(InvalidFirstName<T> value),
    @required TResult invalidLastName(InvalidLastName<T> value),
    @required TResult invalidDob(InvalidDob<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidGender(InvalidGender<T> value),
    @required TResult invalidAccountName(InvalidAccountName<T> value),
    @required TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    @required TResult invalidSortCode(InvalidSortCode<T> value),
    @required
        TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
  }) {
    assert(emptyField != null);
    assert(invalidEmail != null);
    assert(invalidFirstName != null);
    assert(invalidLastName != null);
    assert(invalidDob != null);
    assert(invalidPhoneNumber != null);
    assert(invalidGender != null);
    assert(invalidAccountName != null);
    assert(invalidAccountNumber != null);
    assert(invalidSortCode != null);
    assert(uncheckedTermsAndService != null);
    return invalidLastName(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(EmptyField<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult invalidFirstName(InvalidFirstName<T> value),
    TResult invalidLastName(InvalidLastName<T> value),
    TResult invalidDob(InvalidDob<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidGender(InvalidGender<T> value),
    TResult invalidAccountName(InvalidAccountName<T> value),
    TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    TResult invalidSortCode(InvalidSortCode<T> value),
    TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidLastName != null) {
      return invalidLastName(this);
    }
    return orElse();
  }
}

abstract class InvalidLastName<T> implements PaymentSetupValueFailures<T> {
  const factory InvalidLastName({@required String failedValue}) =
      _$InvalidLastName<T>;

  String get failedValue;
  @JsonKey(ignore: true)
  $InvalidLastNameCopyWith<T, InvalidLastName<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidDobCopyWith<T, $Res> {
  factory $InvalidDobCopyWith(
          InvalidDob<T> value, $Res Function(InvalidDob<T>) then) =
      _$InvalidDobCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$InvalidDobCopyWithImpl<T, $Res>
    extends _$PaymentSetupValueFailuresCopyWithImpl<T, $Res>
    implements $InvalidDobCopyWith<T, $Res> {
  _$InvalidDobCopyWithImpl(
      InvalidDob<T> _value, $Res Function(InvalidDob<T>) _then)
      : super(_value, (v) => _then(v as InvalidDob<T>));

  @override
  InvalidDob<T> get _value => super._value as InvalidDob<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidDob<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as String,
    ));
  }
}

/// @nodoc
class _$InvalidDob<T> implements InvalidDob<T> {
  const _$InvalidDob({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final String failedValue;

  @override
  String toString() {
    return 'PaymentSetupValueFailures<$T>.invalidDob(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidDob<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $InvalidDobCopyWith<T, InvalidDob<T>> get copyWith =>
      _$InvalidDobCopyWithImpl<T, InvalidDob<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String failedValue),
    @required TResult invalidEmail(String failedValue),
    @required TResult invalidFirstName(String failedValue),
    @required TResult invalidLastName(String failedValue),
    @required TResult invalidDob(String failedValue),
    @required TResult invalidPhoneNumber(String failedValue),
    @required TResult invalidGender(String failedValue),
    @required TResult invalidAccountName(String failedValue),
    @required TResult invalidAccountNumber(String failedValue),
    @required TResult invalidSortCode(String failedValue),
    @required TResult uncheckedTermsAndService(bool failedValue),
  }) {
    assert(emptyField != null);
    assert(invalidEmail != null);
    assert(invalidFirstName != null);
    assert(invalidLastName != null);
    assert(invalidDob != null);
    assert(invalidPhoneNumber != null);
    assert(invalidGender != null);
    assert(invalidAccountName != null);
    assert(invalidAccountNumber != null);
    assert(invalidSortCode != null);
    assert(uncheckedTermsAndService != null);
    return invalidDob(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String failedValue),
    TResult invalidEmail(String failedValue),
    TResult invalidFirstName(String failedValue),
    TResult invalidLastName(String failedValue),
    TResult invalidDob(String failedValue),
    TResult invalidPhoneNumber(String failedValue),
    TResult invalidGender(String failedValue),
    TResult invalidAccountName(String failedValue),
    TResult invalidAccountNumber(String failedValue),
    TResult invalidSortCode(String failedValue),
    TResult uncheckedTermsAndService(bool failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidDob != null) {
      return invalidDob(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(EmptyField<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult invalidFirstName(InvalidFirstName<T> value),
    @required TResult invalidLastName(InvalidLastName<T> value),
    @required TResult invalidDob(InvalidDob<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidGender(InvalidGender<T> value),
    @required TResult invalidAccountName(InvalidAccountName<T> value),
    @required TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    @required TResult invalidSortCode(InvalidSortCode<T> value),
    @required
        TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
  }) {
    assert(emptyField != null);
    assert(invalidEmail != null);
    assert(invalidFirstName != null);
    assert(invalidLastName != null);
    assert(invalidDob != null);
    assert(invalidPhoneNumber != null);
    assert(invalidGender != null);
    assert(invalidAccountName != null);
    assert(invalidAccountNumber != null);
    assert(invalidSortCode != null);
    assert(uncheckedTermsAndService != null);
    return invalidDob(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(EmptyField<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult invalidFirstName(InvalidFirstName<T> value),
    TResult invalidLastName(InvalidLastName<T> value),
    TResult invalidDob(InvalidDob<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidGender(InvalidGender<T> value),
    TResult invalidAccountName(InvalidAccountName<T> value),
    TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    TResult invalidSortCode(InvalidSortCode<T> value),
    TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidDob != null) {
      return invalidDob(this);
    }
    return orElse();
  }
}

abstract class InvalidDob<T> implements PaymentSetupValueFailures<T> {
  const factory InvalidDob({@required String failedValue}) = _$InvalidDob<T>;

  String get failedValue;
  @JsonKey(ignore: true)
  $InvalidDobCopyWith<T, InvalidDob<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidPhoneNumberCopyWith<T, $Res> {
  factory $InvalidPhoneNumberCopyWith(InvalidPhoneNumber<T> value,
          $Res Function(InvalidPhoneNumber<T>) then) =
      _$InvalidPhoneNumberCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$InvalidPhoneNumberCopyWithImpl<T, $Res>
    extends _$PaymentSetupValueFailuresCopyWithImpl<T, $Res>
    implements $InvalidPhoneNumberCopyWith<T, $Res> {
  _$InvalidPhoneNumberCopyWithImpl(
      InvalidPhoneNumber<T> _value, $Res Function(InvalidPhoneNumber<T>) _then)
      : super(_value, (v) => _then(v as InvalidPhoneNumber<T>));

  @override
  InvalidPhoneNumber<T> get _value => super._value as InvalidPhoneNumber<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidPhoneNumber<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as String,
    ));
  }
}

/// @nodoc
class _$InvalidPhoneNumber<T> implements InvalidPhoneNumber<T> {
  const _$InvalidPhoneNumber({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final String failedValue;

  @override
  String toString() {
    return 'PaymentSetupValueFailures<$T>.invalidPhoneNumber(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidPhoneNumber<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $InvalidPhoneNumberCopyWith<T, InvalidPhoneNumber<T>> get copyWith =>
      _$InvalidPhoneNumberCopyWithImpl<T, InvalidPhoneNumber<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String failedValue),
    @required TResult invalidEmail(String failedValue),
    @required TResult invalidFirstName(String failedValue),
    @required TResult invalidLastName(String failedValue),
    @required TResult invalidDob(String failedValue),
    @required TResult invalidPhoneNumber(String failedValue),
    @required TResult invalidGender(String failedValue),
    @required TResult invalidAccountName(String failedValue),
    @required TResult invalidAccountNumber(String failedValue),
    @required TResult invalidSortCode(String failedValue),
    @required TResult uncheckedTermsAndService(bool failedValue),
  }) {
    assert(emptyField != null);
    assert(invalidEmail != null);
    assert(invalidFirstName != null);
    assert(invalidLastName != null);
    assert(invalidDob != null);
    assert(invalidPhoneNumber != null);
    assert(invalidGender != null);
    assert(invalidAccountName != null);
    assert(invalidAccountNumber != null);
    assert(invalidSortCode != null);
    assert(uncheckedTermsAndService != null);
    return invalidPhoneNumber(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String failedValue),
    TResult invalidEmail(String failedValue),
    TResult invalidFirstName(String failedValue),
    TResult invalidLastName(String failedValue),
    TResult invalidDob(String failedValue),
    TResult invalidPhoneNumber(String failedValue),
    TResult invalidGender(String failedValue),
    TResult invalidAccountName(String failedValue),
    TResult invalidAccountNumber(String failedValue),
    TResult invalidSortCode(String failedValue),
    TResult uncheckedTermsAndService(bool failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidPhoneNumber != null) {
      return invalidPhoneNumber(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(EmptyField<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult invalidFirstName(InvalidFirstName<T> value),
    @required TResult invalidLastName(InvalidLastName<T> value),
    @required TResult invalidDob(InvalidDob<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidGender(InvalidGender<T> value),
    @required TResult invalidAccountName(InvalidAccountName<T> value),
    @required TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    @required TResult invalidSortCode(InvalidSortCode<T> value),
    @required
        TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
  }) {
    assert(emptyField != null);
    assert(invalidEmail != null);
    assert(invalidFirstName != null);
    assert(invalidLastName != null);
    assert(invalidDob != null);
    assert(invalidPhoneNumber != null);
    assert(invalidGender != null);
    assert(invalidAccountName != null);
    assert(invalidAccountNumber != null);
    assert(invalidSortCode != null);
    assert(uncheckedTermsAndService != null);
    return invalidPhoneNumber(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(EmptyField<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult invalidFirstName(InvalidFirstName<T> value),
    TResult invalidLastName(InvalidLastName<T> value),
    TResult invalidDob(InvalidDob<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidGender(InvalidGender<T> value),
    TResult invalidAccountName(InvalidAccountName<T> value),
    TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    TResult invalidSortCode(InvalidSortCode<T> value),
    TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidPhoneNumber != null) {
      return invalidPhoneNumber(this);
    }
    return orElse();
  }
}

abstract class InvalidPhoneNumber<T> implements PaymentSetupValueFailures<T> {
  const factory InvalidPhoneNumber({@required String failedValue}) =
      _$InvalidPhoneNumber<T>;

  String get failedValue;
  @JsonKey(ignore: true)
  $InvalidPhoneNumberCopyWith<T, InvalidPhoneNumber<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidGenderCopyWith<T, $Res> {
  factory $InvalidGenderCopyWith(
          InvalidGender<T> value, $Res Function(InvalidGender<T>) then) =
      _$InvalidGenderCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$InvalidGenderCopyWithImpl<T, $Res>
    extends _$PaymentSetupValueFailuresCopyWithImpl<T, $Res>
    implements $InvalidGenderCopyWith<T, $Res> {
  _$InvalidGenderCopyWithImpl(
      InvalidGender<T> _value, $Res Function(InvalidGender<T>) _then)
      : super(_value, (v) => _then(v as InvalidGender<T>));

  @override
  InvalidGender<T> get _value => super._value as InvalidGender<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidGender<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as String,
    ));
  }
}

/// @nodoc
class _$InvalidGender<T> implements InvalidGender<T> {
  const _$InvalidGender({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final String failedValue;

  @override
  String toString() {
    return 'PaymentSetupValueFailures<$T>.invalidGender(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidGender<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $InvalidGenderCopyWith<T, InvalidGender<T>> get copyWith =>
      _$InvalidGenderCopyWithImpl<T, InvalidGender<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String failedValue),
    @required TResult invalidEmail(String failedValue),
    @required TResult invalidFirstName(String failedValue),
    @required TResult invalidLastName(String failedValue),
    @required TResult invalidDob(String failedValue),
    @required TResult invalidPhoneNumber(String failedValue),
    @required TResult invalidGender(String failedValue),
    @required TResult invalidAccountName(String failedValue),
    @required TResult invalidAccountNumber(String failedValue),
    @required TResult invalidSortCode(String failedValue),
    @required TResult uncheckedTermsAndService(bool failedValue),
  }) {
    assert(emptyField != null);
    assert(invalidEmail != null);
    assert(invalidFirstName != null);
    assert(invalidLastName != null);
    assert(invalidDob != null);
    assert(invalidPhoneNumber != null);
    assert(invalidGender != null);
    assert(invalidAccountName != null);
    assert(invalidAccountNumber != null);
    assert(invalidSortCode != null);
    assert(uncheckedTermsAndService != null);
    return invalidGender(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String failedValue),
    TResult invalidEmail(String failedValue),
    TResult invalidFirstName(String failedValue),
    TResult invalidLastName(String failedValue),
    TResult invalidDob(String failedValue),
    TResult invalidPhoneNumber(String failedValue),
    TResult invalidGender(String failedValue),
    TResult invalidAccountName(String failedValue),
    TResult invalidAccountNumber(String failedValue),
    TResult invalidSortCode(String failedValue),
    TResult uncheckedTermsAndService(bool failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidGender != null) {
      return invalidGender(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(EmptyField<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult invalidFirstName(InvalidFirstName<T> value),
    @required TResult invalidLastName(InvalidLastName<T> value),
    @required TResult invalidDob(InvalidDob<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidGender(InvalidGender<T> value),
    @required TResult invalidAccountName(InvalidAccountName<T> value),
    @required TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    @required TResult invalidSortCode(InvalidSortCode<T> value),
    @required
        TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
  }) {
    assert(emptyField != null);
    assert(invalidEmail != null);
    assert(invalidFirstName != null);
    assert(invalidLastName != null);
    assert(invalidDob != null);
    assert(invalidPhoneNumber != null);
    assert(invalidGender != null);
    assert(invalidAccountName != null);
    assert(invalidAccountNumber != null);
    assert(invalidSortCode != null);
    assert(uncheckedTermsAndService != null);
    return invalidGender(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(EmptyField<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult invalidFirstName(InvalidFirstName<T> value),
    TResult invalidLastName(InvalidLastName<T> value),
    TResult invalidDob(InvalidDob<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidGender(InvalidGender<T> value),
    TResult invalidAccountName(InvalidAccountName<T> value),
    TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    TResult invalidSortCode(InvalidSortCode<T> value),
    TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidGender != null) {
      return invalidGender(this);
    }
    return orElse();
  }
}

abstract class InvalidGender<T> implements PaymentSetupValueFailures<T> {
  const factory InvalidGender({@required String failedValue}) =
      _$InvalidGender<T>;

  String get failedValue;
  @JsonKey(ignore: true)
  $InvalidGenderCopyWith<T, InvalidGender<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidAccountNameCopyWith<T, $Res> {
  factory $InvalidAccountNameCopyWith(InvalidAccountName<T> value,
          $Res Function(InvalidAccountName<T>) then) =
      _$InvalidAccountNameCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$InvalidAccountNameCopyWithImpl<T, $Res>
    extends _$PaymentSetupValueFailuresCopyWithImpl<T, $Res>
    implements $InvalidAccountNameCopyWith<T, $Res> {
  _$InvalidAccountNameCopyWithImpl(
      InvalidAccountName<T> _value, $Res Function(InvalidAccountName<T>) _then)
      : super(_value, (v) => _then(v as InvalidAccountName<T>));

  @override
  InvalidAccountName<T> get _value => super._value as InvalidAccountName<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidAccountName<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as String,
    ));
  }
}

/// @nodoc
class _$InvalidAccountName<T> implements InvalidAccountName<T> {
  const _$InvalidAccountName({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final String failedValue;

  @override
  String toString() {
    return 'PaymentSetupValueFailures<$T>.invalidAccountName(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidAccountName<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $InvalidAccountNameCopyWith<T, InvalidAccountName<T>> get copyWith =>
      _$InvalidAccountNameCopyWithImpl<T, InvalidAccountName<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String failedValue),
    @required TResult invalidEmail(String failedValue),
    @required TResult invalidFirstName(String failedValue),
    @required TResult invalidLastName(String failedValue),
    @required TResult invalidDob(String failedValue),
    @required TResult invalidPhoneNumber(String failedValue),
    @required TResult invalidGender(String failedValue),
    @required TResult invalidAccountName(String failedValue),
    @required TResult invalidAccountNumber(String failedValue),
    @required TResult invalidSortCode(String failedValue),
    @required TResult uncheckedTermsAndService(bool failedValue),
  }) {
    assert(emptyField != null);
    assert(invalidEmail != null);
    assert(invalidFirstName != null);
    assert(invalidLastName != null);
    assert(invalidDob != null);
    assert(invalidPhoneNumber != null);
    assert(invalidGender != null);
    assert(invalidAccountName != null);
    assert(invalidAccountNumber != null);
    assert(invalidSortCode != null);
    assert(uncheckedTermsAndService != null);
    return invalidAccountName(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String failedValue),
    TResult invalidEmail(String failedValue),
    TResult invalidFirstName(String failedValue),
    TResult invalidLastName(String failedValue),
    TResult invalidDob(String failedValue),
    TResult invalidPhoneNumber(String failedValue),
    TResult invalidGender(String failedValue),
    TResult invalidAccountName(String failedValue),
    TResult invalidAccountNumber(String failedValue),
    TResult invalidSortCode(String failedValue),
    TResult uncheckedTermsAndService(bool failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidAccountName != null) {
      return invalidAccountName(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(EmptyField<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult invalidFirstName(InvalidFirstName<T> value),
    @required TResult invalidLastName(InvalidLastName<T> value),
    @required TResult invalidDob(InvalidDob<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidGender(InvalidGender<T> value),
    @required TResult invalidAccountName(InvalidAccountName<T> value),
    @required TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    @required TResult invalidSortCode(InvalidSortCode<T> value),
    @required
        TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
  }) {
    assert(emptyField != null);
    assert(invalidEmail != null);
    assert(invalidFirstName != null);
    assert(invalidLastName != null);
    assert(invalidDob != null);
    assert(invalidPhoneNumber != null);
    assert(invalidGender != null);
    assert(invalidAccountName != null);
    assert(invalidAccountNumber != null);
    assert(invalidSortCode != null);
    assert(uncheckedTermsAndService != null);
    return invalidAccountName(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(EmptyField<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult invalidFirstName(InvalidFirstName<T> value),
    TResult invalidLastName(InvalidLastName<T> value),
    TResult invalidDob(InvalidDob<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidGender(InvalidGender<T> value),
    TResult invalidAccountName(InvalidAccountName<T> value),
    TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    TResult invalidSortCode(InvalidSortCode<T> value),
    TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidAccountName != null) {
      return invalidAccountName(this);
    }
    return orElse();
  }
}

abstract class InvalidAccountName<T> implements PaymentSetupValueFailures<T> {
  const factory InvalidAccountName({@required String failedValue}) =
      _$InvalidAccountName<T>;

  String get failedValue;
  @JsonKey(ignore: true)
  $InvalidAccountNameCopyWith<T, InvalidAccountName<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidAccountNumberCopyWith<T, $Res> {
  factory $InvalidAccountNumberCopyWith(InvalidAccountNumber<T> value,
          $Res Function(InvalidAccountNumber<T>) then) =
      _$InvalidAccountNumberCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$InvalidAccountNumberCopyWithImpl<T, $Res>
    extends _$PaymentSetupValueFailuresCopyWithImpl<T, $Res>
    implements $InvalidAccountNumberCopyWith<T, $Res> {
  _$InvalidAccountNumberCopyWithImpl(InvalidAccountNumber<T> _value,
      $Res Function(InvalidAccountNumber<T>) _then)
      : super(_value, (v) => _then(v as InvalidAccountNumber<T>));

  @override
  InvalidAccountNumber<T> get _value => super._value as InvalidAccountNumber<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidAccountNumber<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as String,
    ));
  }
}

/// @nodoc
class _$InvalidAccountNumber<T> implements InvalidAccountNumber<T> {
  const _$InvalidAccountNumber({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final String failedValue;

  @override
  String toString() {
    return 'PaymentSetupValueFailures<$T>.invalidAccountNumber(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidAccountNumber<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $InvalidAccountNumberCopyWith<T, InvalidAccountNumber<T>> get copyWith =>
      _$InvalidAccountNumberCopyWithImpl<T, InvalidAccountNumber<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String failedValue),
    @required TResult invalidEmail(String failedValue),
    @required TResult invalidFirstName(String failedValue),
    @required TResult invalidLastName(String failedValue),
    @required TResult invalidDob(String failedValue),
    @required TResult invalidPhoneNumber(String failedValue),
    @required TResult invalidGender(String failedValue),
    @required TResult invalidAccountName(String failedValue),
    @required TResult invalidAccountNumber(String failedValue),
    @required TResult invalidSortCode(String failedValue),
    @required TResult uncheckedTermsAndService(bool failedValue),
  }) {
    assert(emptyField != null);
    assert(invalidEmail != null);
    assert(invalidFirstName != null);
    assert(invalidLastName != null);
    assert(invalidDob != null);
    assert(invalidPhoneNumber != null);
    assert(invalidGender != null);
    assert(invalidAccountName != null);
    assert(invalidAccountNumber != null);
    assert(invalidSortCode != null);
    assert(uncheckedTermsAndService != null);
    return invalidAccountNumber(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String failedValue),
    TResult invalidEmail(String failedValue),
    TResult invalidFirstName(String failedValue),
    TResult invalidLastName(String failedValue),
    TResult invalidDob(String failedValue),
    TResult invalidPhoneNumber(String failedValue),
    TResult invalidGender(String failedValue),
    TResult invalidAccountName(String failedValue),
    TResult invalidAccountNumber(String failedValue),
    TResult invalidSortCode(String failedValue),
    TResult uncheckedTermsAndService(bool failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidAccountNumber != null) {
      return invalidAccountNumber(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(EmptyField<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult invalidFirstName(InvalidFirstName<T> value),
    @required TResult invalidLastName(InvalidLastName<T> value),
    @required TResult invalidDob(InvalidDob<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidGender(InvalidGender<T> value),
    @required TResult invalidAccountName(InvalidAccountName<T> value),
    @required TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    @required TResult invalidSortCode(InvalidSortCode<T> value),
    @required
        TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
  }) {
    assert(emptyField != null);
    assert(invalidEmail != null);
    assert(invalidFirstName != null);
    assert(invalidLastName != null);
    assert(invalidDob != null);
    assert(invalidPhoneNumber != null);
    assert(invalidGender != null);
    assert(invalidAccountName != null);
    assert(invalidAccountNumber != null);
    assert(invalidSortCode != null);
    assert(uncheckedTermsAndService != null);
    return invalidAccountNumber(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(EmptyField<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult invalidFirstName(InvalidFirstName<T> value),
    TResult invalidLastName(InvalidLastName<T> value),
    TResult invalidDob(InvalidDob<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidGender(InvalidGender<T> value),
    TResult invalidAccountName(InvalidAccountName<T> value),
    TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    TResult invalidSortCode(InvalidSortCode<T> value),
    TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidAccountNumber != null) {
      return invalidAccountNumber(this);
    }
    return orElse();
  }
}

abstract class InvalidAccountNumber<T> implements PaymentSetupValueFailures<T> {
  const factory InvalidAccountNumber({@required String failedValue}) =
      _$InvalidAccountNumber<T>;

  String get failedValue;
  @JsonKey(ignore: true)
  $InvalidAccountNumberCopyWith<T, InvalidAccountNumber<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidSortCodeCopyWith<T, $Res> {
  factory $InvalidSortCodeCopyWith(
          InvalidSortCode<T> value, $Res Function(InvalidSortCode<T>) then) =
      _$InvalidSortCodeCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$InvalidSortCodeCopyWithImpl<T, $Res>
    extends _$PaymentSetupValueFailuresCopyWithImpl<T, $Res>
    implements $InvalidSortCodeCopyWith<T, $Res> {
  _$InvalidSortCodeCopyWithImpl(
      InvalidSortCode<T> _value, $Res Function(InvalidSortCode<T>) _then)
      : super(_value, (v) => _then(v as InvalidSortCode<T>));

  @override
  InvalidSortCode<T> get _value => super._value as InvalidSortCode<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidSortCode<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as String,
    ));
  }
}

/// @nodoc
class _$InvalidSortCode<T> implements InvalidSortCode<T> {
  const _$InvalidSortCode({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final String failedValue;

  @override
  String toString() {
    return 'PaymentSetupValueFailures<$T>.invalidSortCode(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidSortCode<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $InvalidSortCodeCopyWith<T, InvalidSortCode<T>> get copyWith =>
      _$InvalidSortCodeCopyWithImpl<T, InvalidSortCode<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String failedValue),
    @required TResult invalidEmail(String failedValue),
    @required TResult invalidFirstName(String failedValue),
    @required TResult invalidLastName(String failedValue),
    @required TResult invalidDob(String failedValue),
    @required TResult invalidPhoneNumber(String failedValue),
    @required TResult invalidGender(String failedValue),
    @required TResult invalidAccountName(String failedValue),
    @required TResult invalidAccountNumber(String failedValue),
    @required TResult invalidSortCode(String failedValue),
    @required TResult uncheckedTermsAndService(bool failedValue),
  }) {
    assert(emptyField != null);
    assert(invalidEmail != null);
    assert(invalidFirstName != null);
    assert(invalidLastName != null);
    assert(invalidDob != null);
    assert(invalidPhoneNumber != null);
    assert(invalidGender != null);
    assert(invalidAccountName != null);
    assert(invalidAccountNumber != null);
    assert(invalidSortCode != null);
    assert(uncheckedTermsAndService != null);
    return invalidSortCode(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String failedValue),
    TResult invalidEmail(String failedValue),
    TResult invalidFirstName(String failedValue),
    TResult invalidLastName(String failedValue),
    TResult invalidDob(String failedValue),
    TResult invalidPhoneNumber(String failedValue),
    TResult invalidGender(String failedValue),
    TResult invalidAccountName(String failedValue),
    TResult invalidAccountNumber(String failedValue),
    TResult invalidSortCode(String failedValue),
    TResult uncheckedTermsAndService(bool failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidSortCode != null) {
      return invalidSortCode(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(EmptyField<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult invalidFirstName(InvalidFirstName<T> value),
    @required TResult invalidLastName(InvalidLastName<T> value),
    @required TResult invalidDob(InvalidDob<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidGender(InvalidGender<T> value),
    @required TResult invalidAccountName(InvalidAccountName<T> value),
    @required TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    @required TResult invalidSortCode(InvalidSortCode<T> value),
    @required
        TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
  }) {
    assert(emptyField != null);
    assert(invalidEmail != null);
    assert(invalidFirstName != null);
    assert(invalidLastName != null);
    assert(invalidDob != null);
    assert(invalidPhoneNumber != null);
    assert(invalidGender != null);
    assert(invalidAccountName != null);
    assert(invalidAccountNumber != null);
    assert(invalidSortCode != null);
    assert(uncheckedTermsAndService != null);
    return invalidSortCode(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(EmptyField<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult invalidFirstName(InvalidFirstName<T> value),
    TResult invalidLastName(InvalidLastName<T> value),
    TResult invalidDob(InvalidDob<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidGender(InvalidGender<T> value),
    TResult invalidAccountName(InvalidAccountName<T> value),
    TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    TResult invalidSortCode(InvalidSortCode<T> value),
    TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidSortCode != null) {
      return invalidSortCode(this);
    }
    return orElse();
  }
}

abstract class InvalidSortCode<T> implements PaymentSetupValueFailures<T> {
  const factory InvalidSortCode({@required String failedValue}) =
      _$InvalidSortCode<T>;

  String get failedValue;
  @JsonKey(ignore: true)
  $InvalidSortCodeCopyWith<T, InvalidSortCode<T>> get copyWith;
}

/// @nodoc
abstract class $UncheckedTermsAndServiceCopyWith<T, $Res> {
  factory $UncheckedTermsAndServiceCopyWith(UncheckedTermsAndService<T> value,
          $Res Function(UncheckedTermsAndService<T>) then) =
      _$UncheckedTermsAndServiceCopyWithImpl<T, $Res>;
  $Res call({bool failedValue});
}

/// @nodoc
class _$UncheckedTermsAndServiceCopyWithImpl<T, $Res>
    extends _$PaymentSetupValueFailuresCopyWithImpl<T, $Res>
    implements $UncheckedTermsAndServiceCopyWith<T, $Res> {
  _$UncheckedTermsAndServiceCopyWithImpl(UncheckedTermsAndService<T> _value,
      $Res Function(UncheckedTermsAndService<T>) _then)
      : super(_value, (v) => _then(v as UncheckedTermsAndService<T>));

  @override
  UncheckedTermsAndService<T> get _value =>
      super._value as UncheckedTermsAndService<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(UncheckedTermsAndService<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as bool,
    ));
  }
}

/// @nodoc
class _$UncheckedTermsAndService<T> implements UncheckedTermsAndService<T> {
  const _$UncheckedTermsAndService({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final bool failedValue;

  @override
  String toString() {
    return 'PaymentSetupValueFailures<$T>.uncheckedTermsAndService(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UncheckedTermsAndService<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @JsonKey(ignore: true)
  @override
  $UncheckedTermsAndServiceCopyWith<T, UncheckedTermsAndService<T>>
      get copyWith => _$UncheckedTermsAndServiceCopyWithImpl<T,
          UncheckedTermsAndService<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String failedValue),
    @required TResult invalidEmail(String failedValue),
    @required TResult invalidFirstName(String failedValue),
    @required TResult invalidLastName(String failedValue),
    @required TResult invalidDob(String failedValue),
    @required TResult invalidPhoneNumber(String failedValue),
    @required TResult invalidGender(String failedValue),
    @required TResult invalidAccountName(String failedValue),
    @required TResult invalidAccountNumber(String failedValue),
    @required TResult invalidSortCode(String failedValue),
    @required TResult uncheckedTermsAndService(bool failedValue),
  }) {
    assert(emptyField != null);
    assert(invalidEmail != null);
    assert(invalidFirstName != null);
    assert(invalidLastName != null);
    assert(invalidDob != null);
    assert(invalidPhoneNumber != null);
    assert(invalidGender != null);
    assert(invalidAccountName != null);
    assert(invalidAccountNumber != null);
    assert(invalidSortCode != null);
    assert(uncheckedTermsAndService != null);
    return uncheckedTermsAndService(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String failedValue),
    TResult invalidEmail(String failedValue),
    TResult invalidFirstName(String failedValue),
    TResult invalidLastName(String failedValue),
    TResult invalidDob(String failedValue),
    TResult invalidPhoneNumber(String failedValue),
    TResult invalidGender(String failedValue),
    TResult invalidAccountName(String failedValue),
    TResult invalidAccountNumber(String failedValue),
    TResult invalidSortCode(String failedValue),
    TResult uncheckedTermsAndService(bool failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (uncheckedTermsAndService != null) {
      return uncheckedTermsAndService(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(EmptyField<T> value),
    @required TResult invalidEmail(InvalidEmail<T> value),
    @required TResult invalidFirstName(InvalidFirstName<T> value),
    @required TResult invalidLastName(InvalidLastName<T> value),
    @required TResult invalidDob(InvalidDob<T> value),
    @required TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    @required TResult invalidGender(InvalidGender<T> value),
    @required TResult invalidAccountName(InvalidAccountName<T> value),
    @required TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    @required TResult invalidSortCode(InvalidSortCode<T> value),
    @required
        TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
  }) {
    assert(emptyField != null);
    assert(invalidEmail != null);
    assert(invalidFirstName != null);
    assert(invalidLastName != null);
    assert(invalidDob != null);
    assert(invalidPhoneNumber != null);
    assert(invalidGender != null);
    assert(invalidAccountName != null);
    assert(invalidAccountNumber != null);
    assert(invalidSortCode != null);
    assert(uncheckedTermsAndService != null);
    return uncheckedTermsAndService(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(EmptyField<T> value),
    TResult invalidEmail(InvalidEmail<T> value),
    TResult invalidFirstName(InvalidFirstName<T> value),
    TResult invalidLastName(InvalidLastName<T> value),
    TResult invalidDob(InvalidDob<T> value),
    TResult invalidPhoneNumber(InvalidPhoneNumber<T> value),
    TResult invalidGender(InvalidGender<T> value),
    TResult invalidAccountName(InvalidAccountName<T> value),
    TResult invalidAccountNumber(InvalidAccountNumber<T> value),
    TResult invalidSortCode(InvalidSortCode<T> value),
    TResult uncheckedTermsAndService(UncheckedTermsAndService<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (uncheckedTermsAndService != null) {
      return uncheckedTermsAndService(this);
    }
    return orElse();
  }
}

abstract class UncheckedTermsAndService<T>
    implements PaymentSetupValueFailures<T> {
  const factory UncheckedTermsAndService({@required bool failedValue}) =
      _$UncheckedTermsAndService<T>;

  bool get failedValue;
  @JsonKey(ignore: true)
  $UncheckedTermsAndServiceCopyWith<T, UncheckedTermsAndService<T>>
      get copyWith;
}
