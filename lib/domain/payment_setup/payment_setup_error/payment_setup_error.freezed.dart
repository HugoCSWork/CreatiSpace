// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'payment_setup_error.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$PaymentSetupErrorFailureTearOff {
  const _$PaymentSetupErrorFailureTearOff();

// ignore: unused_element
  CancelledByUser cancelledByUser() {
    return const CancelledByUser();
  }

// ignore: unused_element
  InvalidPersonalInformation invalidPersonalInformation() {
    return const InvalidPersonalInformation();
  }

// ignore: unused_element
  InvalidAddressInformation invalidAddressInformation() {
    return const InvalidAddressInformation();
  }

// ignore: unused_element
  InvalidPaymentInformation invalidPaymentInformation() {
    return const InvalidPaymentInformation();
  }

// ignore: unused_element
  InvalidDocumentInformation invalidDocumentInformation() {
    return const InvalidDocumentInformation();
  }

// ignore: unused_element
  ErrorFindingAddress errorFindingAddress() {
    return const ErrorFindingAddress();
  }
}

/// @nodoc
// ignore: unused_element
const $PaymentSetupErrorFailure = _$PaymentSetupErrorFailureTearOff();

/// @nodoc
mixin _$PaymentSetupErrorFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult cancelledByUser(),
    @required TResult invalidPersonalInformation(),
    @required TResult invalidAddressInformation(),
    @required TResult invalidPaymentInformation(),
    @required TResult invalidDocumentInformation(),
    @required TResult errorFindingAddress(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult cancelledByUser(),
    TResult invalidPersonalInformation(),
    TResult invalidAddressInformation(),
    TResult invalidPaymentInformation(),
    TResult invalidDocumentInformation(),
    TResult errorFindingAddress(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult cancelledByUser(CancelledByUser value),
    @required
        TResult invalidPersonalInformation(InvalidPersonalInformation value),
    @required
        TResult invalidAddressInformation(InvalidAddressInformation value),
    @required
        TResult invalidPaymentInformation(InvalidPaymentInformation value),
    @required
        TResult invalidDocumentInformation(InvalidDocumentInformation value),
    @required TResult errorFindingAddress(ErrorFindingAddress value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult cancelledByUser(CancelledByUser value),
    TResult invalidPersonalInformation(InvalidPersonalInformation value),
    TResult invalidAddressInformation(InvalidAddressInformation value),
    TResult invalidPaymentInformation(InvalidPaymentInformation value),
    TResult invalidDocumentInformation(InvalidDocumentInformation value),
    TResult errorFindingAddress(ErrorFindingAddress value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $PaymentSetupErrorFailureCopyWith<$Res> {
  factory $PaymentSetupErrorFailureCopyWith(PaymentSetupErrorFailure value,
          $Res Function(PaymentSetupErrorFailure) then) =
      _$PaymentSetupErrorFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$PaymentSetupErrorFailureCopyWithImpl<$Res>
    implements $PaymentSetupErrorFailureCopyWith<$Res> {
  _$PaymentSetupErrorFailureCopyWithImpl(this._value, this._then);

  final PaymentSetupErrorFailure _value;
  // ignore: unused_field
  final $Res Function(PaymentSetupErrorFailure) _then;
}

/// @nodoc
abstract class $CancelledByUserCopyWith<$Res> {
  factory $CancelledByUserCopyWith(
          CancelledByUser value, $Res Function(CancelledByUser) then) =
      _$CancelledByUserCopyWithImpl<$Res>;
}

/// @nodoc
class _$CancelledByUserCopyWithImpl<$Res>
    extends _$PaymentSetupErrorFailureCopyWithImpl<$Res>
    implements $CancelledByUserCopyWith<$Res> {
  _$CancelledByUserCopyWithImpl(
      CancelledByUser _value, $Res Function(CancelledByUser) _then)
      : super(_value, (v) => _then(v as CancelledByUser));

  @override
  CancelledByUser get _value => super._value as CancelledByUser;
}

/// @nodoc
class _$CancelledByUser implements CancelledByUser {
  const _$CancelledByUser();

  @override
  String toString() {
    return 'PaymentSetupErrorFailure.cancelledByUser()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is CancelledByUser);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult cancelledByUser(),
    @required TResult invalidPersonalInformation(),
    @required TResult invalidAddressInformation(),
    @required TResult invalidPaymentInformation(),
    @required TResult invalidDocumentInformation(),
    @required TResult errorFindingAddress(),
  }) {
    assert(cancelledByUser != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(invalidPaymentInformation != null);
    assert(invalidDocumentInformation != null);
    assert(errorFindingAddress != null);
    return cancelledByUser();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult cancelledByUser(),
    TResult invalidPersonalInformation(),
    TResult invalidAddressInformation(),
    TResult invalidPaymentInformation(),
    TResult invalidDocumentInformation(),
    TResult errorFindingAddress(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (cancelledByUser != null) {
      return cancelledByUser();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult cancelledByUser(CancelledByUser value),
    @required
        TResult invalidPersonalInformation(InvalidPersonalInformation value),
    @required
        TResult invalidAddressInformation(InvalidAddressInformation value),
    @required
        TResult invalidPaymentInformation(InvalidPaymentInformation value),
    @required
        TResult invalidDocumentInformation(InvalidDocumentInformation value),
    @required TResult errorFindingAddress(ErrorFindingAddress value),
  }) {
    assert(cancelledByUser != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(invalidPaymentInformation != null);
    assert(invalidDocumentInformation != null);
    assert(errorFindingAddress != null);
    return cancelledByUser(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult cancelledByUser(CancelledByUser value),
    TResult invalidPersonalInformation(InvalidPersonalInformation value),
    TResult invalidAddressInformation(InvalidAddressInformation value),
    TResult invalidPaymentInformation(InvalidPaymentInformation value),
    TResult invalidDocumentInformation(InvalidDocumentInformation value),
    TResult errorFindingAddress(ErrorFindingAddress value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (cancelledByUser != null) {
      return cancelledByUser(this);
    }
    return orElse();
  }
}

abstract class CancelledByUser implements PaymentSetupErrorFailure {
  const factory CancelledByUser() = _$CancelledByUser;
}

/// @nodoc
abstract class $InvalidPersonalInformationCopyWith<$Res> {
  factory $InvalidPersonalInformationCopyWith(InvalidPersonalInformation value,
          $Res Function(InvalidPersonalInformation) then) =
      _$InvalidPersonalInformationCopyWithImpl<$Res>;
}

/// @nodoc
class _$InvalidPersonalInformationCopyWithImpl<$Res>
    extends _$PaymentSetupErrorFailureCopyWithImpl<$Res>
    implements $InvalidPersonalInformationCopyWith<$Res> {
  _$InvalidPersonalInformationCopyWithImpl(InvalidPersonalInformation _value,
      $Res Function(InvalidPersonalInformation) _then)
      : super(_value, (v) => _then(v as InvalidPersonalInformation));

  @override
  InvalidPersonalInformation get _value =>
      super._value as InvalidPersonalInformation;
}

/// @nodoc
class _$InvalidPersonalInformation implements InvalidPersonalInformation {
  const _$InvalidPersonalInformation();

  @override
  String toString() {
    return 'PaymentSetupErrorFailure.invalidPersonalInformation()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidPersonalInformation);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult cancelledByUser(),
    @required TResult invalidPersonalInformation(),
    @required TResult invalidAddressInformation(),
    @required TResult invalidPaymentInformation(),
    @required TResult invalidDocumentInformation(),
    @required TResult errorFindingAddress(),
  }) {
    assert(cancelledByUser != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(invalidPaymentInformation != null);
    assert(invalidDocumentInformation != null);
    assert(errorFindingAddress != null);
    return invalidPersonalInformation();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult cancelledByUser(),
    TResult invalidPersonalInformation(),
    TResult invalidAddressInformation(),
    TResult invalidPaymentInformation(),
    TResult invalidDocumentInformation(),
    TResult errorFindingAddress(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidPersonalInformation != null) {
      return invalidPersonalInformation();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult cancelledByUser(CancelledByUser value),
    @required
        TResult invalidPersonalInformation(InvalidPersonalInformation value),
    @required
        TResult invalidAddressInformation(InvalidAddressInformation value),
    @required
        TResult invalidPaymentInformation(InvalidPaymentInformation value),
    @required
        TResult invalidDocumentInformation(InvalidDocumentInformation value),
    @required TResult errorFindingAddress(ErrorFindingAddress value),
  }) {
    assert(cancelledByUser != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(invalidPaymentInformation != null);
    assert(invalidDocumentInformation != null);
    assert(errorFindingAddress != null);
    return invalidPersonalInformation(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult cancelledByUser(CancelledByUser value),
    TResult invalidPersonalInformation(InvalidPersonalInformation value),
    TResult invalidAddressInformation(InvalidAddressInformation value),
    TResult invalidPaymentInformation(InvalidPaymentInformation value),
    TResult invalidDocumentInformation(InvalidDocumentInformation value),
    TResult errorFindingAddress(ErrorFindingAddress value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidPersonalInformation != null) {
      return invalidPersonalInformation(this);
    }
    return orElse();
  }
}

abstract class InvalidPersonalInformation implements PaymentSetupErrorFailure {
  const factory InvalidPersonalInformation() = _$InvalidPersonalInformation;
}

/// @nodoc
abstract class $InvalidAddressInformationCopyWith<$Res> {
  factory $InvalidAddressInformationCopyWith(InvalidAddressInformation value,
          $Res Function(InvalidAddressInformation) then) =
      _$InvalidAddressInformationCopyWithImpl<$Res>;
}

/// @nodoc
class _$InvalidAddressInformationCopyWithImpl<$Res>
    extends _$PaymentSetupErrorFailureCopyWithImpl<$Res>
    implements $InvalidAddressInformationCopyWith<$Res> {
  _$InvalidAddressInformationCopyWithImpl(InvalidAddressInformation _value,
      $Res Function(InvalidAddressInformation) _then)
      : super(_value, (v) => _then(v as InvalidAddressInformation));

  @override
  InvalidAddressInformation get _value =>
      super._value as InvalidAddressInformation;
}

/// @nodoc
class _$InvalidAddressInformation implements InvalidAddressInformation {
  const _$InvalidAddressInformation();

  @override
  String toString() {
    return 'PaymentSetupErrorFailure.invalidAddressInformation()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidAddressInformation);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult cancelledByUser(),
    @required TResult invalidPersonalInformation(),
    @required TResult invalidAddressInformation(),
    @required TResult invalidPaymentInformation(),
    @required TResult invalidDocumentInformation(),
    @required TResult errorFindingAddress(),
  }) {
    assert(cancelledByUser != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(invalidPaymentInformation != null);
    assert(invalidDocumentInformation != null);
    assert(errorFindingAddress != null);
    return invalidAddressInformation();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult cancelledByUser(),
    TResult invalidPersonalInformation(),
    TResult invalidAddressInformation(),
    TResult invalidPaymentInformation(),
    TResult invalidDocumentInformation(),
    TResult errorFindingAddress(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidAddressInformation != null) {
      return invalidAddressInformation();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult cancelledByUser(CancelledByUser value),
    @required
        TResult invalidPersonalInformation(InvalidPersonalInformation value),
    @required
        TResult invalidAddressInformation(InvalidAddressInformation value),
    @required
        TResult invalidPaymentInformation(InvalidPaymentInformation value),
    @required
        TResult invalidDocumentInformation(InvalidDocumentInformation value),
    @required TResult errorFindingAddress(ErrorFindingAddress value),
  }) {
    assert(cancelledByUser != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(invalidPaymentInformation != null);
    assert(invalidDocumentInformation != null);
    assert(errorFindingAddress != null);
    return invalidAddressInformation(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult cancelledByUser(CancelledByUser value),
    TResult invalidPersonalInformation(InvalidPersonalInformation value),
    TResult invalidAddressInformation(InvalidAddressInformation value),
    TResult invalidPaymentInformation(InvalidPaymentInformation value),
    TResult invalidDocumentInformation(InvalidDocumentInformation value),
    TResult errorFindingAddress(ErrorFindingAddress value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidAddressInformation != null) {
      return invalidAddressInformation(this);
    }
    return orElse();
  }
}

abstract class InvalidAddressInformation implements PaymentSetupErrorFailure {
  const factory InvalidAddressInformation() = _$InvalidAddressInformation;
}

/// @nodoc
abstract class $InvalidPaymentInformationCopyWith<$Res> {
  factory $InvalidPaymentInformationCopyWith(InvalidPaymentInformation value,
          $Res Function(InvalidPaymentInformation) then) =
      _$InvalidPaymentInformationCopyWithImpl<$Res>;
}

/// @nodoc
class _$InvalidPaymentInformationCopyWithImpl<$Res>
    extends _$PaymentSetupErrorFailureCopyWithImpl<$Res>
    implements $InvalidPaymentInformationCopyWith<$Res> {
  _$InvalidPaymentInformationCopyWithImpl(InvalidPaymentInformation _value,
      $Res Function(InvalidPaymentInformation) _then)
      : super(_value, (v) => _then(v as InvalidPaymentInformation));

  @override
  InvalidPaymentInformation get _value =>
      super._value as InvalidPaymentInformation;
}

/// @nodoc
class _$InvalidPaymentInformation implements InvalidPaymentInformation {
  const _$InvalidPaymentInformation();

  @override
  String toString() {
    return 'PaymentSetupErrorFailure.invalidPaymentInformation()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidPaymentInformation);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult cancelledByUser(),
    @required TResult invalidPersonalInformation(),
    @required TResult invalidAddressInformation(),
    @required TResult invalidPaymentInformation(),
    @required TResult invalidDocumentInformation(),
    @required TResult errorFindingAddress(),
  }) {
    assert(cancelledByUser != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(invalidPaymentInformation != null);
    assert(invalidDocumentInformation != null);
    assert(errorFindingAddress != null);
    return invalidPaymentInformation();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult cancelledByUser(),
    TResult invalidPersonalInformation(),
    TResult invalidAddressInformation(),
    TResult invalidPaymentInformation(),
    TResult invalidDocumentInformation(),
    TResult errorFindingAddress(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidPaymentInformation != null) {
      return invalidPaymentInformation();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult cancelledByUser(CancelledByUser value),
    @required
        TResult invalidPersonalInformation(InvalidPersonalInformation value),
    @required
        TResult invalidAddressInformation(InvalidAddressInformation value),
    @required
        TResult invalidPaymentInformation(InvalidPaymentInformation value),
    @required
        TResult invalidDocumentInformation(InvalidDocumentInformation value),
    @required TResult errorFindingAddress(ErrorFindingAddress value),
  }) {
    assert(cancelledByUser != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(invalidPaymentInformation != null);
    assert(invalidDocumentInformation != null);
    assert(errorFindingAddress != null);
    return invalidPaymentInformation(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult cancelledByUser(CancelledByUser value),
    TResult invalidPersonalInformation(InvalidPersonalInformation value),
    TResult invalidAddressInformation(InvalidAddressInformation value),
    TResult invalidPaymentInformation(InvalidPaymentInformation value),
    TResult invalidDocumentInformation(InvalidDocumentInformation value),
    TResult errorFindingAddress(ErrorFindingAddress value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidPaymentInformation != null) {
      return invalidPaymentInformation(this);
    }
    return orElse();
  }
}

abstract class InvalidPaymentInformation implements PaymentSetupErrorFailure {
  const factory InvalidPaymentInformation() = _$InvalidPaymentInformation;
}

/// @nodoc
abstract class $InvalidDocumentInformationCopyWith<$Res> {
  factory $InvalidDocumentInformationCopyWith(InvalidDocumentInformation value,
          $Res Function(InvalidDocumentInformation) then) =
      _$InvalidDocumentInformationCopyWithImpl<$Res>;
}

/// @nodoc
class _$InvalidDocumentInformationCopyWithImpl<$Res>
    extends _$PaymentSetupErrorFailureCopyWithImpl<$Res>
    implements $InvalidDocumentInformationCopyWith<$Res> {
  _$InvalidDocumentInformationCopyWithImpl(InvalidDocumentInformation _value,
      $Res Function(InvalidDocumentInformation) _then)
      : super(_value, (v) => _then(v as InvalidDocumentInformation));

  @override
  InvalidDocumentInformation get _value =>
      super._value as InvalidDocumentInformation;
}

/// @nodoc
class _$InvalidDocumentInformation implements InvalidDocumentInformation {
  const _$InvalidDocumentInformation();

  @override
  String toString() {
    return 'PaymentSetupErrorFailure.invalidDocumentInformation()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidDocumentInformation);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult cancelledByUser(),
    @required TResult invalidPersonalInformation(),
    @required TResult invalidAddressInformation(),
    @required TResult invalidPaymentInformation(),
    @required TResult invalidDocumentInformation(),
    @required TResult errorFindingAddress(),
  }) {
    assert(cancelledByUser != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(invalidPaymentInformation != null);
    assert(invalidDocumentInformation != null);
    assert(errorFindingAddress != null);
    return invalidDocumentInformation();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult cancelledByUser(),
    TResult invalidPersonalInformation(),
    TResult invalidAddressInformation(),
    TResult invalidPaymentInformation(),
    TResult invalidDocumentInformation(),
    TResult errorFindingAddress(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidDocumentInformation != null) {
      return invalidDocumentInformation();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult cancelledByUser(CancelledByUser value),
    @required
        TResult invalidPersonalInformation(InvalidPersonalInformation value),
    @required
        TResult invalidAddressInformation(InvalidAddressInformation value),
    @required
        TResult invalidPaymentInformation(InvalidPaymentInformation value),
    @required
        TResult invalidDocumentInformation(InvalidDocumentInformation value),
    @required TResult errorFindingAddress(ErrorFindingAddress value),
  }) {
    assert(cancelledByUser != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(invalidPaymentInformation != null);
    assert(invalidDocumentInformation != null);
    assert(errorFindingAddress != null);
    return invalidDocumentInformation(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult cancelledByUser(CancelledByUser value),
    TResult invalidPersonalInformation(InvalidPersonalInformation value),
    TResult invalidAddressInformation(InvalidAddressInformation value),
    TResult invalidPaymentInformation(InvalidPaymentInformation value),
    TResult invalidDocumentInformation(InvalidDocumentInformation value),
    TResult errorFindingAddress(ErrorFindingAddress value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidDocumentInformation != null) {
      return invalidDocumentInformation(this);
    }
    return orElse();
  }
}

abstract class InvalidDocumentInformation implements PaymentSetupErrorFailure {
  const factory InvalidDocumentInformation() = _$InvalidDocumentInformation;
}

/// @nodoc
abstract class $ErrorFindingAddressCopyWith<$Res> {
  factory $ErrorFindingAddressCopyWith(
          ErrorFindingAddress value, $Res Function(ErrorFindingAddress) then) =
      _$ErrorFindingAddressCopyWithImpl<$Res>;
}

/// @nodoc
class _$ErrorFindingAddressCopyWithImpl<$Res>
    extends _$PaymentSetupErrorFailureCopyWithImpl<$Res>
    implements $ErrorFindingAddressCopyWith<$Res> {
  _$ErrorFindingAddressCopyWithImpl(
      ErrorFindingAddress _value, $Res Function(ErrorFindingAddress) _then)
      : super(_value, (v) => _then(v as ErrorFindingAddress));

  @override
  ErrorFindingAddress get _value => super._value as ErrorFindingAddress;
}

/// @nodoc
class _$ErrorFindingAddress implements ErrorFindingAddress {
  const _$ErrorFindingAddress();

  @override
  String toString() {
    return 'PaymentSetupErrorFailure.errorFindingAddress()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ErrorFindingAddress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult cancelledByUser(),
    @required TResult invalidPersonalInformation(),
    @required TResult invalidAddressInformation(),
    @required TResult invalidPaymentInformation(),
    @required TResult invalidDocumentInformation(),
    @required TResult errorFindingAddress(),
  }) {
    assert(cancelledByUser != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(invalidPaymentInformation != null);
    assert(invalidDocumentInformation != null);
    assert(errorFindingAddress != null);
    return errorFindingAddress();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult cancelledByUser(),
    TResult invalidPersonalInformation(),
    TResult invalidAddressInformation(),
    TResult invalidPaymentInformation(),
    TResult invalidDocumentInformation(),
    TResult errorFindingAddress(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (errorFindingAddress != null) {
      return errorFindingAddress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult cancelledByUser(CancelledByUser value),
    @required
        TResult invalidPersonalInformation(InvalidPersonalInformation value),
    @required
        TResult invalidAddressInformation(InvalidAddressInformation value),
    @required
        TResult invalidPaymentInformation(InvalidPaymentInformation value),
    @required
        TResult invalidDocumentInformation(InvalidDocumentInformation value),
    @required TResult errorFindingAddress(ErrorFindingAddress value),
  }) {
    assert(cancelledByUser != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(invalidPaymentInformation != null);
    assert(invalidDocumentInformation != null);
    assert(errorFindingAddress != null);
    return errorFindingAddress(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult cancelledByUser(CancelledByUser value),
    TResult invalidPersonalInformation(InvalidPersonalInformation value),
    TResult invalidAddressInformation(InvalidAddressInformation value),
    TResult invalidPaymentInformation(InvalidPaymentInformation value),
    TResult invalidDocumentInformation(InvalidDocumentInformation value),
    TResult errorFindingAddress(ErrorFindingAddress value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (errorFindingAddress != null) {
      return errorFindingAddress(this);
    }
    return orElse();
  }
}

abstract class ErrorFindingAddress implements PaymentSetupErrorFailure {
  const factory ErrorFindingAddress() = _$ErrorFindingAddress;
}
