// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'item_value_failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$ItemValueFailureTearOff {
  const _$ItemValueFailureTearOff();

// ignore: unused_element
  InvalidName<T> invalidName<T>({@required String failedValue}) {
    return InvalidName<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidDescription<T> invalidDescription<T>({@required String failedValue}) {
    return InvalidDescription<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidPrice<T> invalidPrice<T>({@required double failedValue}) {
    return InvalidPrice<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidQuantity<T> invalidQuantity<T>({@required int failedValue}) {
    return InvalidQuantity<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidDeliveryFee<T> invalidDeliveryFee<T>({@required double failedValue}) {
    return InvalidDeliveryFee<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidImage<T> invalidImage<T>({@required String failedValue}) {
    return InvalidImage<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidImageName<T> invalidImageName<T>({@required String failedValue}) {
    return InvalidImageName<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  Multiline<T> multiline<T>({@required String failedValue}) {
    return Multiline<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidPurchasable<T> invalidPurchasable<T>({@required bool failedValue}) {
    return InvalidPurchasable<T>(
      failedValue: failedValue,
    );
  }

// ignore: unused_element
  InvalidImageLength<T> invalidImageLength<T>(
      {@required T failedValue, @required int max}) {
    return InvalidImageLength<T>(
      failedValue: failedValue,
      max: max,
    );
  }

// ignore: unused_element
  ExceedingLength<T> exceedingLength<T>(
      {@required T failedValue, @required int max}) {
    return ExceedingLength<T>(
      failedValue: failedValue,
      max: max,
    );
  }

// ignore: unused_element
  Empty<T> empty<T>({@required T failedValue}) {
    return Empty<T>(
      failedValue: failedValue,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $ItemValueFailure = _$ItemValueFailureTearOff();

/// @nodoc
mixin _$ItemValueFailure<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidName(String failedValue),
    @required TResult invalidDescription(String failedValue),
    @required TResult invalidPrice(double failedValue),
    @required TResult invalidQuantity(int failedValue),
    @required TResult invalidDeliveryFee(double failedValue),
    @required TResult invalidImage(String failedValue),
    @required TResult invalidImageName(String failedValue),
    @required TResult multiline(String failedValue),
    @required TResult invalidPurchasable(bool failedValue),
    @required TResult invalidImageLength(T failedValue, int max),
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidName(String failedValue),
    TResult invalidDescription(String failedValue),
    TResult invalidPrice(double failedValue),
    TResult invalidQuantity(int failedValue),
    TResult invalidDeliveryFee(double failedValue),
    TResult invalidImage(String failedValue),
    TResult invalidImageName(String failedValue),
    TResult multiline(String failedValue),
    TResult invalidPurchasable(bool failedValue),
    TResult invalidImageLength(T failedValue, int max),
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidName(InvalidName<T> value),
    @required TResult invalidDescription(InvalidDescription<T> value),
    @required TResult invalidPrice(InvalidPrice<T> value),
    @required TResult invalidQuantity(InvalidQuantity<T> value),
    @required TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    @required TResult invalidImage(InvalidImage<T> value),
    @required TResult invalidImageName(InvalidImageName<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult invalidPurchasable(InvalidPurchasable<T> value),
    @required TResult invalidImageLength(InvalidImageLength<T> value),
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidName(InvalidName<T> value),
    TResult invalidDescription(InvalidDescription<T> value),
    TResult invalidPrice(InvalidPrice<T> value),
    TResult invalidQuantity(InvalidQuantity<T> value),
    TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    TResult invalidImage(InvalidImage<T> value),
    TResult invalidImageName(InvalidImageName<T> value),
    TResult multiline(Multiline<T> value),
    TResult invalidPurchasable(InvalidPurchasable<T> value),
    TResult invalidImageLength(InvalidImageLength<T> value),
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $ItemValueFailureCopyWith<T, $Res> {
  factory $ItemValueFailureCopyWith(
          ItemValueFailure<T> value, $Res Function(ItemValueFailure<T>) then) =
      _$ItemValueFailureCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$ItemValueFailureCopyWithImpl<T, $Res>
    implements $ItemValueFailureCopyWith<T, $Res> {
  _$ItemValueFailureCopyWithImpl(this._value, this._then);

  final ItemValueFailure<T> _value;
  // ignore: unused_field
  final $Res Function(ItemValueFailure<T>) _then;
}

/// @nodoc
abstract class $InvalidNameCopyWith<T, $Res> {
  factory $InvalidNameCopyWith(
          InvalidName<T> value, $Res Function(InvalidName<T>) then) =
      _$InvalidNameCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$InvalidNameCopyWithImpl<T, $Res>
    extends _$ItemValueFailureCopyWithImpl<T, $Res>
    implements $InvalidNameCopyWith<T, $Res> {
  _$InvalidNameCopyWithImpl(
      InvalidName<T> _value, $Res Function(InvalidName<T>) _then)
      : super(_value, (v) => _then(v as InvalidName<T>));

  @override
  InvalidName<T> get _value => super._value as InvalidName<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidName<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as String,
    ));
  }
}

/// @nodoc
class _$InvalidName<T> implements InvalidName<T> {
  const _$InvalidName({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final String failedValue;

  @override
  String toString() {
    return 'ItemValueFailure<$T>.invalidName(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidName<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidNameCopyWith<T, InvalidName<T>> get copyWith =>
      _$InvalidNameCopyWithImpl<T, InvalidName<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidName(String failedValue),
    @required TResult invalidDescription(String failedValue),
    @required TResult invalidPrice(double failedValue),
    @required TResult invalidQuantity(int failedValue),
    @required TResult invalidDeliveryFee(double failedValue),
    @required TResult invalidImage(String failedValue),
    @required TResult invalidImageName(String failedValue),
    @required TResult multiline(String failedValue),
    @required TResult invalidPurchasable(bool failedValue),
    @required TResult invalidImageLength(T failedValue, int max),
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return invalidName(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidName(String failedValue),
    TResult invalidDescription(String failedValue),
    TResult invalidPrice(double failedValue),
    TResult invalidQuantity(int failedValue),
    TResult invalidDeliveryFee(double failedValue),
    TResult invalidImage(String failedValue),
    TResult invalidImageName(String failedValue),
    TResult multiline(String failedValue),
    TResult invalidPurchasable(bool failedValue),
    TResult invalidImageLength(T failedValue, int max),
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidName != null) {
      return invalidName(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidName(InvalidName<T> value),
    @required TResult invalidDescription(InvalidDescription<T> value),
    @required TResult invalidPrice(InvalidPrice<T> value),
    @required TResult invalidQuantity(InvalidQuantity<T> value),
    @required TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    @required TResult invalidImage(InvalidImage<T> value),
    @required TResult invalidImageName(InvalidImageName<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult invalidPurchasable(InvalidPurchasable<T> value),
    @required TResult invalidImageLength(InvalidImageLength<T> value),
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return invalidName(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidName(InvalidName<T> value),
    TResult invalidDescription(InvalidDescription<T> value),
    TResult invalidPrice(InvalidPrice<T> value),
    TResult invalidQuantity(InvalidQuantity<T> value),
    TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    TResult invalidImage(InvalidImage<T> value),
    TResult invalidImageName(InvalidImageName<T> value),
    TResult multiline(Multiline<T> value),
    TResult invalidPurchasable(InvalidPurchasable<T> value),
    TResult invalidImageLength(InvalidImageLength<T> value),
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidName != null) {
      return invalidName(this);
    }
    return orElse();
  }
}

abstract class InvalidName<T> implements ItemValueFailure<T> {
  const factory InvalidName({@required String failedValue}) = _$InvalidName<T>;

  String get failedValue;
  $InvalidNameCopyWith<T, InvalidName<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidDescriptionCopyWith<T, $Res> {
  factory $InvalidDescriptionCopyWith(InvalidDescription<T> value,
          $Res Function(InvalidDescription<T>) then) =
      _$InvalidDescriptionCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$InvalidDescriptionCopyWithImpl<T, $Res>
    extends _$ItemValueFailureCopyWithImpl<T, $Res>
    implements $InvalidDescriptionCopyWith<T, $Res> {
  _$InvalidDescriptionCopyWithImpl(
      InvalidDescription<T> _value, $Res Function(InvalidDescription<T>) _then)
      : super(_value, (v) => _then(v as InvalidDescription<T>));

  @override
  InvalidDescription<T> get _value => super._value as InvalidDescription<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidDescription<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as String,
    ));
  }
}

/// @nodoc
class _$InvalidDescription<T> implements InvalidDescription<T> {
  const _$InvalidDescription({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final String failedValue;

  @override
  String toString() {
    return 'ItemValueFailure<$T>.invalidDescription(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidDescription<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidDescriptionCopyWith<T, InvalidDescription<T>> get copyWith =>
      _$InvalidDescriptionCopyWithImpl<T, InvalidDescription<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidName(String failedValue),
    @required TResult invalidDescription(String failedValue),
    @required TResult invalidPrice(double failedValue),
    @required TResult invalidQuantity(int failedValue),
    @required TResult invalidDeliveryFee(double failedValue),
    @required TResult invalidImage(String failedValue),
    @required TResult invalidImageName(String failedValue),
    @required TResult multiline(String failedValue),
    @required TResult invalidPurchasable(bool failedValue),
    @required TResult invalidImageLength(T failedValue, int max),
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return invalidDescription(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidName(String failedValue),
    TResult invalidDescription(String failedValue),
    TResult invalidPrice(double failedValue),
    TResult invalidQuantity(int failedValue),
    TResult invalidDeliveryFee(double failedValue),
    TResult invalidImage(String failedValue),
    TResult invalidImageName(String failedValue),
    TResult multiline(String failedValue),
    TResult invalidPurchasable(bool failedValue),
    TResult invalidImageLength(T failedValue, int max),
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidDescription != null) {
      return invalidDescription(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidName(InvalidName<T> value),
    @required TResult invalidDescription(InvalidDescription<T> value),
    @required TResult invalidPrice(InvalidPrice<T> value),
    @required TResult invalidQuantity(InvalidQuantity<T> value),
    @required TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    @required TResult invalidImage(InvalidImage<T> value),
    @required TResult invalidImageName(InvalidImageName<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult invalidPurchasable(InvalidPurchasable<T> value),
    @required TResult invalidImageLength(InvalidImageLength<T> value),
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return invalidDescription(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidName(InvalidName<T> value),
    TResult invalidDescription(InvalidDescription<T> value),
    TResult invalidPrice(InvalidPrice<T> value),
    TResult invalidQuantity(InvalidQuantity<T> value),
    TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    TResult invalidImage(InvalidImage<T> value),
    TResult invalidImageName(InvalidImageName<T> value),
    TResult multiline(Multiline<T> value),
    TResult invalidPurchasable(InvalidPurchasable<T> value),
    TResult invalidImageLength(InvalidImageLength<T> value),
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidDescription != null) {
      return invalidDescription(this);
    }
    return orElse();
  }
}

abstract class InvalidDescription<T> implements ItemValueFailure<T> {
  const factory InvalidDescription({@required String failedValue}) =
      _$InvalidDescription<T>;

  String get failedValue;
  $InvalidDescriptionCopyWith<T, InvalidDescription<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidPriceCopyWith<T, $Res> {
  factory $InvalidPriceCopyWith(
          InvalidPrice<T> value, $Res Function(InvalidPrice<T>) then) =
      _$InvalidPriceCopyWithImpl<T, $Res>;
  $Res call({double failedValue});
}

/// @nodoc
class _$InvalidPriceCopyWithImpl<T, $Res>
    extends _$ItemValueFailureCopyWithImpl<T, $Res>
    implements $InvalidPriceCopyWith<T, $Res> {
  _$InvalidPriceCopyWithImpl(
      InvalidPrice<T> _value, $Res Function(InvalidPrice<T>) _then)
      : super(_value, (v) => _then(v as InvalidPrice<T>));

  @override
  InvalidPrice<T> get _value => super._value as InvalidPrice<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidPrice<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as double,
    ));
  }
}

/// @nodoc
class _$InvalidPrice<T> implements InvalidPrice<T> {
  const _$InvalidPrice({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final double failedValue;

  @override
  String toString() {
    return 'ItemValueFailure<$T>.invalidPrice(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidPrice<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidPriceCopyWith<T, InvalidPrice<T>> get copyWith =>
      _$InvalidPriceCopyWithImpl<T, InvalidPrice<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidName(String failedValue),
    @required TResult invalidDescription(String failedValue),
    @required TResult invalidPrice(double failedValue),
    @required TResult invalidQuantity(int failedValue),
    @required TResult invalidDeliveryFee(double failedValue),
    @required TResult invalidImage(String failedValue),
    @required TResult invalidImageName(String failedValue),
    @required TResult multiline(String failedValue),
    @required TResult invalidPurchasable(bool failedValue),
    @required TResult invalidImageLength(T failedValue, int max),
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return invalidPrice(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidName(String failedValue),
    TResult invalidDescription(String failedValue),
    TResult invalidPrice(double failedValue),
    TResult invalidQuantity(int failedValue),
    TResult invalidDeliveryFee(double failedValue),
    TResult invalidImage(String failedValue),
    TResult invalidImageName(String failedValue),
    TResult multiline(String failedValue),
    TResult invalidPurchasable(bool failedValue),
    TResult invalidImageLength(T failedValue, int max),
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidPrice != null) {
      return invalidPrice(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidName(InvalidName<T> value),
    @required TResult invalidDescription(InvalidDescription<T> value),
    @required TResult invalidPrice(InvalidPrice<T> value),
    @required TResult invalidQuantity(InvalidQuantity<T> value),
    @required TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    @required TResult invalidImage(InvalidImage<T> value),
    @required TResult invalidImageName(InvalidImageName<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult invalidPurchasable(InvalidPurchasable<T> value),
    @required TResult invalidImageLength(InvalidImageLength<T> value),
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return invalidPrice(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidName(InvalidName<T> value),
    TResult invalidDescription(InvalidDescription<T> value),
    TResult invalidPrice(InvalidPrice<T> value),
    TResult invalidQuantity(InvalidQuantity<T> value),
    TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    TResult invalidImage(InvalidImage<T> value),
    TResult invalidImageName(InvalidImageName<T> value),
    TResult multiline(Multiline<T> value),
    TResult invalidPurchasable(InvalidPurchasable<T> value),
    TResult invalidImageLength(InvalidImageLength<T> value),
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidPrice != null) {
      return invalidPrice(this);
    }
    return orElse();
  }
}

abstract class InvalidPrice<T> implements ItemValueFailure<T> {
  const factory InvalidPrice({@required double failedValue}) =
      _$InvalidPrice<T>;

  double get failedValue;
  $InvalidPriceCopyWith<T, InvalidPrice<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidQuantityCopyWith<T, $Res> {
  factory $InvalidQuantityCopyWith(
          InvalidQuantity<T> value, $Res Function(InvalidQuantity<T>) then) =
      _$InvalidQuantityCopyWithImpl<T, $Res>;
  $Res call({int failedValue});
}

/// @nodoc
class _$InvalidQuantityCopyWithImpl<T, $Res>
    extends _$ItemValueFailureCopyWithImpl<T, $Res>
    implements $InvalidQuantityCopyWith<T, $Res> {
  _$InvalidQuantityCopyWithImpl(
      InvalidQuantity<T> _value, $Res Function(InvalidQuantity<T>) _then)
      : super(_value, (v) => _then(v as InvalidQuantity<T>));

  @override
  InvalidQuantity<T> get _value => super._value as InvalidQuantity<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidQuantity<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as int,
    ));
  }
}

/// @nodoc
class _$InvalidQuantity<T> implements InvalidQuantity<T> {
  const _$InvalidQuantity({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final int failedValue;

  @override
  String toString() {
    return 'ItemValueFailure<$T>.invalidQuantity(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidQuantity<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidQuantityCopyWith<T, InvalidQuantity<T>> get copyWith =>
      _$InvalidQuantityCopyWithImpl<T, InvalidQuantity<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidName(String failedValue),
    @required TResult invalidDescription(String failedValue),
    @required TResult invalidPrice(double failedValue),
    @required TResult invalidQuantity(int failedValue),
    @required TResult invalidDeliveryFee(double failedValue),
    @required TResult invalidImage(String failedValue),
    @required TResult invalidImageName(String failedValue),
    @required TResult multiline(String failedValue),
    @required TResult invalidPurchasable(bool failedValue),
    @required TResult invalidImageLength(T failedValue, int max),
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return invalidQuantity(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidName(String failedValue),
    TResult invalidDescription(String failedValue),
    TResult invalidPrice(double failedValue),
    TResult invalidQuantity(int failedValue),
    TResult invalidDeliveryFee(double failedValue),
    TResult invalidImage(String failedValue),
    TResult invalidImageName(String failedValue),
    TResult multiline(String failedValue),
    TResult invalidPurchasable(bool failedValue),
    TResult invalidImageLength(T failedValue, int max),
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidQuantity != null) {
      return invalidQuantity(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidName(InvalidName<T> value),
    @required TResult invalidDescription(InvalidDescription<T> value),
    @required TResult invalidPrice(InvalidPrice<T> value),
    @required TResult invalidQuantity(InvalidQuantity<T> value),
    @required TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    @required TResult invalidImage(InvalidImage<T> value),
    @required TResult invalidImageName(InvalidImageName<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult invalidPurchasable(InvalidPurchasable<T> value),
    @required TResult invalidImageLength(InvalidImageLength<T> value),
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return invalidQuantity(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidName(InvalidName<T> value),
    TResult invalidDescription(InvalidDescription<T> value),
    TResult invalidPrice(InvalidPrice<T> value),
    TResult invalidQuantity(InvalidQuantity<T> value),
    TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    TResult invalidImage(InvalidImage<T> value),
    TResult invalidImageName(InvalidImageName<T> value),
    TResult multiline(Multiline<T> value),
    TResult invalidPurchasable(InvalidPurchasable<T> value),
    TResult invalidImageLength(InvalidImageLength<T> value),
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidQuantity != null) {
      return invalidQuantity(this);
    }
    return orElse();
  }
}

abstract class InvalidQuantity<T> implements ItemValueFailure<T> {
  const factory InvalidQuantity({@required int failedValue}) =
      _$InvalidQuantity<T>;

  int get failedValue;
  $InvalidQuantityCopyWith<T, InvalidQuantity<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidDeliveryFeeCopyWith<T, $Res> {
  factory $InvalidDeliveryFeeCopyWith(InvalidDeliveryFee<T> value,
          $Res Function(InvalidDeliveryFee<T>) then) =
      _$InvalidDeliveryFeeCopyWithImpl<T, $Res>;
  $Res call({double failedValue});
}

/// @nodoc
class _$InvalidDeliveryFeeCopyWithImpl<T, $Res>
    extends _$ItemValueFailureCopyWithImpl<T, $Res>
    implements $InvalidDeliveryFeeCopyWith<T, $Res> {
  _$InvalidDeliveryFeeCopyWithImpl(
      InvalidDeliveryFee<T> _value, $Res Function(InvalidDeliveryFee<T>) _then)
      : super(_value, (v) => _then(v as InvalidDeliveryFee<T>));

  @override
  InvalidDeliveryFee<T> get _value => super._value as InvalidDeliveryFee<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidDeliveryFee<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as double,
    ));
  }
}

/// @nodoc
class _$InvalidDeliveryFee<T> implements InvalidDeliveryFee<T> {
  const _$InvalidDeliveryFee({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final double failedValue;

  @override
  String toString() {
    return 'ItemValueFailure<$T>.invalidDeliveryFee(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidDeliveryFee<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidDeliveryFeeCopyWith<T, InvalidDeliveryFee<T>> get copyWith =>
      _$InvalidDeliveryFeeCopyWithImpl<T, InvalidDeliveryFee<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidName(String failedValue),
    @required TResult invalidDescription(String failedValue),
    @required TResult invalidPrice(double failedValue),
    @required TResult invalidQuantity(int failedValue),
    @required TResult invalidDeliveryFee(double failedValue),
    @required TResult invalidImage(String failedValue),
    @required TResult invalidImageName(String failedValue),
    @required TResult multiline(String failedValue),
    @required TResult invalidPurchasable(bool failedValue),
    @required TResult invalidImageLength(T failedValue, int max),
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return invalidDeliveryFee(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidName(String failedValue),
    TResult invalidDescription(String failedValue),
    TResult invalidPrice(double failedValue),
    TResult invalidQuantity(int failedValue),
    TResult invalidDeliveryFee(double failedValue),
    TResult invalidImage(String failedValue),
    TResult invalidImageName(String failedValue),
    TResult multiline(String failedValue),
    TResult invalidPurchasable(bool failedValue),
    TResult invalidImageLength(T failedValue, int max),
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidDeliveryFee != null) {
      return invalidDeliveryFee(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidName(InvalidName<T> value),
    @required TResult invalidDescription(InvalidDescription<T> value),
    @required TResult invalidPrice(InvalidPrice<T> value),
    @required TResult invalidQuantity(InvalidQuantity<T> value),
    @required TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    @required TResult invalidImage(InvalidImage<T> value),
    @required TResult invalidImageName(InvalidImageName<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult invalidPurchasable(InvalidPurchasable<T> value),
    @required TResult invalidImageLength(InvalidImageLength<T> value),
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return invalidDeliveryFee(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidName(InvalidName<T> value),
    TResult invalidDescription(InvalidDescription<T> value),
    TResult invalidPrice(InvalidPrice<T> value),
    TResult invalidQuantity(InvalidQuantity<T> value),
    TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    TResult invalidImage(InvalidImage<T> value),
    TResult invalidImageName(InvalidImageName<T> value),
    TResult multiline(Multiline<T> value),
    TResult invalidPurchasable(InvalidPurchasable<T> value),
    TResult invalidImageLength(InvalidImageLength<T> value),
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidDeliveryFee != null) {
      return invalidDeliveryFee(this);
    }
    return orElse();
  }
}

abstract class InvalidDeliveryFee<T> implements ItemValueFailure<T> {
  const factory InvalidDeliveryFee({@required double failedValue}) =
      _$InvalidDeliveryFee<T>;

  double get failedValue;
  $InvalidDeliveryFeeCopyWith<T, InvalidDeliveryFee<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidImageCopyWith<T, $Res> {
  factory $InvalidImageCopyWith(
          InvalidImage<T> value, $Res Function(InvalidImage<T>) then) =
      _$InvalidImageCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$InvalidImageCopyWithImpl<T, $Res>
    extends _$ItemValueFailureCopyWithImpl<T, $Res>
    implements $InvalidImageCopyWith<T, $Res> {
  _$InvalidImageCopyWithImpl(
      InvalidImage<T> _value, $Res Function(InvalidImage<T>) _then)
      : super(_value, (v) => _then(v as InvalidImage<T>));

  @override
  InvalidImage<T> get _value => super._value as InvalidImage<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidImage<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as String,
    ));
  }
}

/// @nodoc
class _$InvalidImage<T> implements InvalidImage<T> {
  const _$InvalidImage({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final String failedValue;

  @override
  String toString() {
    return 'ItemValueFailure<$T>.invalidImage(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidImage<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidImageCopyWith<T, InvalidImage<T>> get copyWith =>
      _$InvalidImageCopyWithImpl<T, InvalidImage<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidName(String failedValue),
    @required TResult invalidDescription(String failedValue),
    @required TResult invalidPrice(double failedValue),
    @required TResult invalidQuantity(int failedValue),
    @required TResult invalidDeliveryFee(double failedValue),
    @required TResult invalidImage(String failedValue),
    @required TResult invalidImageName(String failedValue),
    @required TResult multiline(String failedValue),
    @required TResult invalidPurchasable(bool failedValue),
    @required TResult invalidImageLength(T failedValue, int max),
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return invalidImage(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidName(String failedValue),
    TResult invalidDescription(String failedValue),
    TResult invalidPrice(double failedValue),
    TResult invalidQuantity(int failedValue),
    TResult invalidDeliveryFee(double failedValue),
    TResult invalidImage(String failedValue),
    TResult invalidImageName(String failedValue),
    TResult multiline(String failedValue),
    TResult invalidPurchasable(bool failedValue),
    TResult invalidImageLength(T failedValue, int max),
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidImage != null) {
      return invalidImage(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidName(InvalidName<T> value),
    @required TResult invalidDescription(InvalidDescription<T> value),
    @required TResult invalidPrice(InvalidPrice<T> value),
    @required TResult invalidQuantity(InvalidQuantity<T> value),
    @required TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    @required TResult invalidImage(InvalidImage<T> value),
    @required TResult invalidImageName(InvalidImageName<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult invalidPurchasable(InvalidPurchasable<T> value),
    @required TResult invalidImageLength(InvalidImageLength<T> value),
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return invalidImage(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidName(InvalidName<T> value),
    TResult invalidDescription(InvalidDescription<T> value),
    TResult invalidPrice(InvalidPrice<T> value),
    TResult invalidQuantity(InvalidQuantity<T> value),
    TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    TResult invalidImage(InvalidImage<T> value),
    TResult invalidImageName(InvalidImageName<T> value),
    TResult multiline(Multiline<T> value),
    TResult invalidPurchasable(InvalidPurchasable<T> value),
    TResult invalidImageLength(InvalidImageLength<T> value),
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidImage != null) {
      return invalidImage(this);
    }
    return orElse();
  }
}

abstract class InvalidImage<T> implements ItemValueFailure<T> {
  const factory InvalidImage({@required String failedValue}) =
      _$InvalidImage<T>;

  String get failedValue;
  $InvalidImageCopyWith<T, InvalidImage<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidImageNameCopyWith<T, $Res> {
  factory $InvalidImageNameCopyWith(
          InvalidImageName<T> value, $Res Function(InvalidImageName<T>) then) =
      _$InvalidImageNameCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$InvalidImageNameCopyWithImpl<T, $Res>
    extends _$ItemValueFailureCopyWithImpl<T, $Res>
    implements $InvalidImageNameCopyWith<T, $Res> {
  _$InvalidImageNameCopyWithImpl(
      InvalidImageName<T> _value, $Res Function(InvalidImageName<T>) _then)
      : super(_value, (v) => _then(v as InvalidImageName<T>));

  @override
  InvalidImageName<T> get _value => super._value as InvalidImageName<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidImageName<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as String,
    ));
  }
}

/// @nodoc
class _$InvalidImageName<T> implements InvalidImageName<T> {
  const _$InvalidImageName({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final String failedValue;

  @override
  String toString() {
    return 'ItemValueFailure<$T>.invalidImageName(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidImageName<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidImageNameCopyWith<T, InvalidImageName<T>> get copyWith =>
      _$InvalidImageNameCopyWithImpl<T, InvalidImageName<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidName(String failedValue),
    @required TResult invalidDescription(String failedValue),
    @required TResult invalidPrice(double failedValue),
    @required TResult invalidQuantity(int failedValue),
    @required TResult invalidDeliveryFee(double failedValue),
    @required TResult invalidImage(String failedValue),
    @required TResult invalidImageName(String failedValue),
    @required TResult multiline(String failedValue),
    @required TResult invalidPurchasable(bool failedValue),
    @required TResult invalidImageLength(T failedValue, int max),
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return invalidImageName(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidName(String failedValue),
    TResult invalidDescription(String failedValue),
    TResult invalidPrice(double failedValue),
    TResult invalidQuantity(int failedValue),
    TResult invalidDeliveryFee(double failedValue),
    TResult invalidImage(String failedValue),
    TResult invalidImageName(String failedValue),
    TResult multiline(String failedValue),
    TResult invalidPurchasable(bool failedValue),
    TResult invalidImageLength(T failedValue, int max),
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidImageName != null) {
      return invalidImageName(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidName(InvalidName<T> value),
    @required TResult invalidDescription(InvalidDescription<T> value),
    @required TResult invalidPrice(InvalidPrice<T> value),
    @required TResult invalidQuantity(InvalidQuantity<T> value),
    @required TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    @required TResult invalidImage(InvalidImage<T> value),
    @required TResult invalidImageName(InvalidImageName<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult invalidPurchasable(InvalidPurchasable<T> value),
    @required TResult invalidImageLength(InvalidImageLength<T> value),
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return invalidImageName(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidName(InvalidName<T> value),
    TResult invalidDescription(InvalidDescription<T> value),
    TResult invalidPrice(InvalidPrice<T> value),
    TResult invalidQuantity(InvalidQuantity<T> value),
    TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    TResult invalidImage(InvalidImage<T> value),
    TResult invalidImageName(InvalidImageName<T> value),
    TResult multiline(Multiline<T> value),
    TResult invalidPurchasable(InvalidPurchasable<T> value),
    TResult invalidImageLength(InvalidImageLength<T> value),
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidImageName != null) {
      return invalidImageName(this);
    }
    return orElse();
  }
}

abstract class InvalidImageName<T> implements ItemValueFailure<T> {
  const factory InvalidImageName({@required String failedValue}) =
      _$InvalidImageName<T>;

  String get failedValue;
  $InvalidImageNameCopyWith<T, InvalidImageName<T>> get copyWith;
}

/// @nodoc
abstract class $MultilineCopyWith<T, $Res> {
  factory $MultilineCopyWith(
          Multiline<T> value, $Res Function(Multiline<T>) then) =
      _$MultilineCopyWithImpl<T, $Res>;
  $Res call({String failedValue});
}

/// @nodoc
class _$MultilineCopyWithImpl<T, $Res>
    extends _$ItemValueFailureCopyWithImpl<T, $Res>
    implements $MultilineCopyWith<T, $Res> {
  _$MultilineCopyWithImpl(
      Multiline<T> _value, $Res Function(Multiline<T>) _then)
      : super(_value, (v) => _then(v as Multiline<T>));

  @override
  Multiline<T> get _value => super._value as Multiline<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(Multiline<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as String,
    ));
  }
}

/// @nodoc
class _$Multiline<T> implements Multiline<T> {
  const _$Multiline({@required this.failedValue}) : assert(failedValue != null);

  @override
  final String failedValue;

  @override
  String toString() {
    return 'ItemValueFailure<$T>.multiline(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Multiline<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $MultilineCopyWith<T, Multiline<T>> get copyWith =>
      _$MultilineCopyWithImpl<T, Multiline<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidName(String failedValue),
    @required TResult invalidDescription(String failedValue),
    @required TResult invalidPrice(double failedValue),
    @required TResult invalidQuantity(int failedValue),
    @required TResult invalidDeliveryFee(double failedValue),
    @required TResult invalidImage(String failedValue),
    @required TResult invalidImageName(String failedValue),
    @required TResult multiline(String failedValue),
    @required TResult invalidPurchasable(bool failedValue),
    @required TResult invalidImageLength(T failedValue, int max),
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return multiline(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidName(String failedValue),
    TResult invalidDescription(String failedValue),
    TResult invalidPrice(double failedValue),
    TResult invalidQuantity(int failedValue),
    TResult invalidDeliveryFee(double failedValue),
    TResult invalidImage(String failedValue),
    TResult invalidImageName(String failedValue),
    TResult multiline(String failedValue),
    TResult invalidPurchasable(bool failedValue),
    TResult invalidImageLength(T failedValue, int max),
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (multiline != null) {
      return multiline(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidName(InvalidName<T> value),
    @required TResult invalidDescription(InvalidDescription<T> value),
    @required TResult invalidPrice(InvalidPrice<T> value),
    @required TResult invalidQuantity(InvalidQuantity<T> value),
    @required TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    @required TResult invalidImage(InvalidImage<T> value),
    @required TResult invalidImageName(InvalidImageName<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult invalidPurchasable(InvalidPurchasable<T> value),
    @required TResult invalidImageLength(InvalidImageLength<T> value),
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return multiline(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidName(InvalidName<T> value),
    TResult invalidDescription(InvalidDescription<T> value),
    TResult invalidPrice(InvalidPrice<T> value),
    TResult invalidQuantity(InvalidQuantity<T> value),
    TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    TResult invalidImage(InvalidImage<T> value),
    TResult invalidImageName(InvalidImageName<T> value),
    TResult multiline(Multiline<T> value),
    TResult invalidPurchasable(InvalidPurchasable<T> value),
    TResult invalidImageLength(InvalidImageLength<T> value),
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (multiline != null) {
      return multiline(this);
    }
    return orElse();
  }
}

abstract class Multiline<T> implements ItemValueFailure<T> {
  const factory Multiline({@required String failedValue}) = _$Multiline<T>;

  String get failedValue;
  $MultilineCopyWith<T, Multiline<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidPurchasableCopyWith<T, $Res> {
  factory $InvalidPurchasableCopyWith(InvalidPurchasable<T> value,
          $Res Function(InvalidPurchasable<T>) then) =
      _$InvalidPurchasableCopyWithImpl<T, $Res>;
  $Res call({bool failedValue});
}

/// @nodoc
class _$InvalidPurchasableCopyWithImpl<T, $Res>
    extends _$ItemValueFailureCopyWithImpl<T, $Res>
    implements $InvalidPurchasableCopyWith<T, $Res> {
  _$InvalidPurchasableCopyWithImpl(
      InvalidPurchasable<T> _value, $Res Function(InvalidPurchasable<T>) _then)
      : super(_value, (v) => _then(v as InvalidPurchasable<T>));

  @override
  InvalidPurchasable<T> get _value => super._value as InvalidPurchasable<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(InvalidPurchasable<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as bool,
    ));
  }
}

/// @nodoc
class _$InvalidPurchasable<T> implements InvalidPurchasable<T> {
  const _$InvalidPurchasable({@required this.failedValue})
      : assert(failedValue != null);

  @override
  final bool failedValue;

  @override
  String toString() {
    return 'ItemValueFailure<$T>.invalidPurchasable(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidPurchasable<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $InvalidPurchasableCopyWith<T, InvalidPurchasable<T>> get copyWith =>
      _$InvalidPurchasableCopyWithImpl<T, InvalidPurchasable<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidName(String failedValue),
    @required TResult invalidDescription(String failedValue),
    @required TResult invalidPrice(double failedValue),
    @required TResult invalidQuantity(int failedValue),
    @required TResult invalidDeliveryFee(double failedValue),
    @required TResult invalidImage(String failedValue),
    @required TResult invalidImageName(String failedValue),
    @required TResult multiline(String failedValue),
    @required TResult invalidPurchasable(bool failedValue),
    @required TResult invalidImageLength(T failedValue, int max),
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return invalidPurchasable(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidName(String failedValue),
    TResult invalidDescription(String failedValue),
    TResult invalidPrice(double failedValue),
    TResult invalidQuantity(int failedValue),
    TResult invalidDeliveryFee(double failedValue),
    TResult invalidImage(String failedValue),
    TResult invalidImageName(String failedValue),
    TResult multiline(String failedValue),
    TResult invalidPurchasable(bool failedValue),
    TResult invalidImageLength(T failedValue, int max),
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidPurchasable != null) {
      return invalidPurchasable(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidName(InvalidName<T> value),
    @required TResult invalidDescription(InvalidDescription<T> value),
    @required TResult invalidPrice(InvalidPrice<T> value),
    @required TResult invalidQuantity(InvalidQuantity<T> value),
    @required TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    @required TResult invalidImage(InvalidImage<T> value),
    @required TResult invalidImageName(InvalidImageName<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult invalidPurchasable(InvalidPurchasable<T> value),
    @required TResult invalidImageLength(InvalidImageLength<T> value),
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return invalidPurchasable(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidName(InvalidName<T> value),
    TResult invalidDescription(InvalidDescription<T> value),
    TResult invalidPrice(InvalidPrice<T> value),
    TResult invalidQuantity(InvalidQuantity<T> value),
    TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    TResult invalidImage(InvalidImage<T> value),
    TResult invalidImageName(InvalidImageName<T> value),
    TResult multiline(Multiline<T> value),
    TResult invalidPurchasable(InvalidPurchasable<T> value),
    TResult invalidImageLength(InvalidImageLength<T> value),
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidPurchasable != null) {
      return invalidPurchasable(this);
    }
    return orElse();
  }
}

abstract class InvalidPurchasable<T> implements ItemValueFailure<T> {
  const factory InvalidPurchasable({@required bool failedValue}) =
      _$InvalidPurchasable<T>;

  bool get failedValue;
  $InvalidPurchasableCopyWith<T, InvalidPurchasable<T>> get copyWith;
}

/// @nodoc
abstract class $InvalidImageLengthCopyWith<T, $Res> {
  factory $InvalidImageLengthCopyWith(InvalidImageLength<T> value,
          $Res Function(InvalidImageLength<T>) then) =
      _$InvalidImageLengthCopyWithImpl<T, $Res>;
  $Res call({T failedValue, int max});
}

/// @nodoc
class _$InvalidImageLengthCopyWithImpl<T, $Res>
    extends _$ItemValueFailureCopyWithImpl<T, $Res>
    implements $InvalidImageLengthCopyWith<T, $Res> {
  _$InvalidImageLengthCopyWithImpl(
      InvalidImageLength<T> _value, $Res Function(InvalidImageLength<T>) _then)
      : super(_value, (v) => _then(v as InvalidImageLength<T>));

  @override
  InvalidImageLength<T> get _value => super._value as InvalidImageLength<T>;

  @override
  $Res call({
    Object failedValue = freezed,
    Object max = freezed,
  }) {
    return _then(InvalidImageLength<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
      max: max == freezed ? _value.max : max as int,
    ));
  }
}

/// @nodoc
class _$InvalidImageLength<T> implements InvalidImageLength<T> {
  const _$InvalidImageLength({@required this.failedValue, @required this.max})
      : assert(failedValue != null),
        assert(max != null);

  @override
  final T failedValue;
  @override
  final int max;

  @override
  String toString() {
    return 'ItemValueFailure<$T>.invalidImageLength(failedValue: $failedValue, max: $max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvalidImageLength<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)) &&
            (identical(other.max, max) ||
                const DeepCollectionEquality().equals(other.max, max)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(failedValue) ^
      const DeepCollectionEquality().hash(max);

  @override
  $InvalidImageLengthCopyWith<T, InvalidImageLength<T>> get copyWith =>
      _$InvalidImageLengthCopyWithImpl<T, InvalidImageLength<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidName(String failedValue),
    @required TResult invalidDescription(String failedValue),
    @required TResult invalidPrice(double failedValue),
    @required TResult invalidQuantity(int failedValue),
    @required TResult invalidDeliveryFee(double failedValue),
    @required TResult invalidImage(String failedValue),
    @required TResult invalidImageName(String failedValue),
    @required TResult multiline(String failedValue),
    @required TResult invalidPurchasable(bool failedValue),
    @required TResult invalidImageLength(T failedValue, int max),
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return invalidImageLength(failedValue, max);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidName(String failedValue),
    TResult invalidDescription(String failedValue),
    TResult invalidPrice(double failedValue),
    TResult invalidQuantity(int failedValue),
    TResult invalidDeliveryFee(double failedValue),
    TResult invalidImage(String failedValue),
    TResult invalidImageName(String failedValue),
    TResult multiline(String failedValue),
    TResult invalidPurchasable(bool failedValue),
    TResult invalidImageLength(T failedValue, int max),
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidImageLength != null) {
      return invalidImageLength(failedValue, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidName(InvalidName<T> value),
    @required TResult invalidDescription(InvalidDescription<T> value),
    @required TResult invalidPrice(InvalidPrice<T> value),
    @required TResult invalidQuantity(InvalidQuantity<T> value),
    @required TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    @required TResult invalidImage(InvalidImage<T> value),
    @required TResult invalidImageName(InvalidImageName<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult invalidPurchasable(InvalidPurchasable<T> value),
    @required TResult invalidImageLength(InvalidImageLength<T> value),
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return invalidImageLength(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidName(InvalidName<T> value),
    TResult invalidDescription(InvalidDescription<T> value),
    TResult invalidPrice(InvalidPrice<T> value),
    TResult invalidQuantity(InvalidQuantity<T> value),
    TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    TResult invalidImage(InvalidImage<T> value),
    TResult invalidImageName(InvalidImageName<T> value),
    TResult multiline(Multiline<T> value),
    TResult invalidPurchasable(InvalidPurchasable<T> value),
    TResult invalidImageLength(InvalidImageLength<T> value),
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidImageLength != null) {
      return invalidImageLength(this);
    }
    return orElse();
  }
}

abstract class InvalidImageLength<T> implements ItemValueFailure<T> {
  const factory InvalidImageLength(
      {@required T failedValue, @required int max}) = _$InvalidImageLength<T>;

  T get failedValue;
  int get max;
  $InvalidImageLengthCopyWith<T, InvalidImageLength<T>> get copyWith;
}

/// @nodoc
abstract class $ExceedingLengthCopyWith<T, $Res> {
  factory $ExceedingLengthCopyWith(
          ExceedingLength<T> value, $Res Function(ExceedingLength<T>) then) =
      _$ExceedingLengthCopyWithImpl<T, $Res>;
  $Res call({T failedValue, int max});
}

/// @nodoc
class _$ExceedingLengthCopyWithImpl<T, $Res>
    extends _$ItemValueFailureCopyWithImpl<T, $Res>
    implements $ExceedingLengthCopyWith<T, $Res> {
  _$ExceedingLengthCopyWithImpl(
      ExceedingLength<T> _value, $Res Function(ExceedingLength<T>) _then)
      : super(_value, (v) => _then(v as ExceedingLength<T>));

  @override
  ExceedingLength<T> get _value => super._value as ExceedingLength<T>;

  @override
  $Res call({
    Object failedValue = freezed,
    Object max = freezed,
  }) {
    return _then(ExceedingLength<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
      max: max == freezed ? _value.max : max as int,
    ));
  }
}

/// @nodoc
class _$ExceedingLength<T> implements ExceedingLength<T> {
  const _$ExceedingLength({@required this.failedValue, @required this.max})
      : assert(failedValue != null),
        assert(max != null);

  @override
  final T failedValue;
  @override
  final int max;

  @override
  String toString() {
    return 'ItemValueFailure<$T>.exceedingLength(failedValue: $failedValue, max: $max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ExceedingLength<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)) &&
            (identical(other.max, max) ||
                const DeepCollectionEquality().equals(other.max, max)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(failedValue) ^
      const DeepCollectionEquality().hash(max);

  @override
  $ExceedingLengthCopyWith<T, ExceedingLength<T>> get copyWith =>
      _$ExceedingLengthCopyWithImpl<T, ExceedingLength<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidName(String failedValue),
    @required TResult invalidDescription(String failedValue),
    @required TResult invalidPrice(double failedValue),
    @required TResult invalidQuantity(int failedValue),
    @required TResult invalidDeliveryFee(double failedValue),
    @required TResult invalidImage(String failedValue),
    @required TResult invalidImageName(String failedValue),
    @required TResult multiline(String failedValue),
    @required TResult invalidPurchasable(bool failedValue),
    @required TResult invalidImageLength(T failedValue, int max),
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return exceedingLength(failedValue, max);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidName(String failedValue),
    TResult invalidDescription(String failedValue),
    TResult invalidPrice(double failedValue),
    TResult invalidQuantity(int failedValue),
    TResult invalidDeliveryFee(double failedValue),
    TResult invalidImage(String failedValue),
    TResult invalidImageName(String failedValue),
    TResult multiline(String failedValue),
    TResult invalidPurchasable(bool failedValue),
    TResult invalidImageLength(T failedValue, int max),
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (exceedingLength != null) {
      return exceedingLength(failedValue, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidName(InvalidName<T> value),
    @required TResult invalidDescription(InvalidDescription<T> value),
    @required TResult invalidPrice(InvalidPrice<T> value),
    @required TResult invalidQuantity(InvalidQuantity<T> value),
    @required TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    @required TResult invalidImage(InvalidImage<T> value),
    @required TResult invalidImageName(InvalidImageName<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult invalidPurchasable(InvalidPurchasable<T> value),
    @required TResult invalidImageLength(InvalidImageLength<T> value),
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return exceedingLength(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidName(InvalidName<T> value),
    TResult invalidDescription(InvalidDescription<T> value),
    TResult invalidPrice(InvalidPrice<T> value),
    TResult invalidQuantity(InvalidQuantity<T> value),
    TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    TResult invalidImage(InvalidImage<T> value),
    TResult invalidImageName(InvalidImageName<T> value),
    TResult multiline(Multiline<T> value),
    TResult invalidPurchasable(InvalidPurchasable<T> value),
    TResult invalidImageLength(InvalidImageLength<T> value),
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (exceedingLength != null) {
      return exceedingLength(this);
    }
    return orElse();
  }
}

abstract class ExceedingLength<T> implements ItemValueFailure<T> {
  const factory ExceedingLength({@required T failedValue, @required int max}) =
      _$ExceedingLength<T>;

  T get failedValue;
  int get max;
  $ExceedingLengthCopyWith<T, ExceedingLength<T>> get copyWith;
}

/// @nodoc
abstract class $EmptyCopyWith<T, $Res> {
  factory $EmptyCopyWith(Empty<T> value, $Res Function(Empty<T>) then) =
      _$EmptyCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$EmptyCopyWithImpl<T, $Res>
    extends _$ItemValueFailureCopyWithImpl<T, $Res>
    implements $EmptyCopyWith<T, $Res> {
  _$EmptyCopyWithImpl(Empty<T> _value, $Res Function(Empty<T>) _then)
      : super(_value, (v) => _then(v as Empty<T>));

  @override
  Empty<T> get _value => super._value as Empty<T>;

  @override
  $Res call({
    Object failedValue = freezed,
  }) {
    return _then(Empty<T>(
      failedValue:
          failedValue == freezed ? _value.failedValue : failedValue as T,
    ));
  }
}

/// @nodoc
class _$Empty<T> implements Empty<T> {
  const _$Empty({@required this.failedValue}) : assert(failedValue != null);

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ItemValueFailure<$T>.empty(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Empty<T> &&
            (identical(other.failedValue, failedValue) ||
                const DeepCollectionEquality()
                    .equals(other.failedValue, failedValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failedValue);

  @override
  $EmptyCopyWith<T, Empty<T>> get copyWith =>
      _$EmptyCopyWithImpl<T, Empty<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult invalidName(String failedValue),
    @required TResult invalidDescription(String failedValue),
    @required TResult invalidPrice(double failedValue),
    @required TResult invalidQuantity(int failedValue),
    @required TResult invalidDeliveryFee(double failedValue),
    @required TResult invalidImage(String failedValue),
    @required TResult invalidImageName(String failedValue),
    @required TResult multiline(String failedValue),
    @required TResult invalidPurchasable(bool failedValue),
    @required TResult invalidImageLength(T failedValue, int max),
    @required TResult exceedingLength(T failedValue, int max),
    @required TResult empty(T failedValue),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return empty(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult invalidName(String failedValue),
    TResult invalidDescription(String failedValue),
    TResult invalidPrice(double failedValue),
    TResult invalidQuantity(int failedValue),
    TResult invalidDeliveryFee(double failedValue),
    TResult invalidImage(String failedValue),
    TResult invalidImageName(String failedValue),
    TResult multiline(String failedValue),
    TResult invalidPurchasable(bool failedValue),
    TResult invalidImageLength(T failedValue, int max),
    TResult exceedingLength(T failedValue, int max),
    TResult empty(T failedValue),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (empty != null) {
      return empty(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult invalidName(InvalidName<T> value),
    @required TResult invalidDescription(InvalidDescription<T> value),
    @required TResult invalidPrice(InvalidPrice<T> value),
    @required TResult invalidQuantity(InvalidQuantity<T> value),
    @required TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    @required TResult invalidImage(InvalidImage<T> value),
    @required TResult invalidImageName(InvalidImageName<T> value),
    @required TResult multiline(Multiline<T> value),
    @required TResult invalidPurchasable(InvalidPurchasable<T> value),
    @required TResult invalidImageLength(InvalidImageLength<T> value),
    @required TResult exceedingLength(ExceedingLength<T> value),
    @required TResult empty(Empty<T> value),
  }) {
    assert(invalidName != null);
    assert(invalidDescription != null);
    assert(invalidPrice != null);
    assert(invalidQuantity != null);
    assert(invalidDeliveryFee != null);
    assert(invalidImage != null);
    assert(invalidImageName != null);
    assert(multiline != null);
    assert(invalidPurchasable != null);
    assert(invalidImageLength != null);
    assert(exceedingLength != null);
    assert(empty != null);
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult invalidName(InvalidName<T> value),
    TResult invalidDescription(InvalidDescription<T> value),
    TResult invalidPrice(InvalidPrice<T> value),
    TResult invalidQuantity(InvalidQuantity<T> value),
    TResult invalidDeliveryFee(InvalidDeliveryFee<T> value),
    TResult invalidImage(InvalidImage<T> value),
    TResult invalidImageName(InvalidImageName<T> value),
    TResult multiline(Multiline<T> value),
    TResult invalidPurchasable(InvalidPurchasable<T> value),
    TResult invalidImageLength(InvalidImageLength<T> value),
    TResult exceedingLength(ExceedingLength<T> value),
    TResult empty(Empty<T> value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class Empty<T> implements ItemValueFailure<T> {
  const factory Empty({@required T failedValue}) = _$Empty<T>;

  T get failedValue;
  $EmptyCopyWith<T, Empty<T>> get copyWith;
}
