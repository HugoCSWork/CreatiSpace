// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'payment_form_errors.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$PaymentFormErrorsTearOff {
  const _$PaymentFormErrorsTearOff();

// ignore: unused_element
  Unexpected unexpected() {
    return const Unexpected();
  }

// ignore: unused_element
  ErrorMakingPayment errorMakingPayment() {
    return const ErrorMakingPayment();
  }

// ignore: unused_element
  Cancelled cancelled() {
    return const Cancelled();
  }
}

/// @nodoc
// ignore: unused_element
const $PaymentFormErrors = _$PaymentFormErrorsTearOff();

/// @nodoc
mixin _$PaymentFormErrors {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unexpected(),
    @required TResult errorMakingPayment(),
    @required TResult cancelled(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unexpected(),
    TResult errorMakingPayment(),
    TResult cancelled(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unexpected(Unexpected value),
    @required TResult errorMakingPayment(ErrorMakingPayment value),
    @required TResult cancelled(Cancelled value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unexpected(Unexpected value),
    TResult errorMakingPayment(ErrorMakingPayment value),
    TResult cancelled(Cancelled value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $PaymentFormErrorsCopyWith<$Res> {
  factory $PaymentFormErrorsCopyWith(
          PaymentFormErrors value, $Res Function(PaymentFormErrors) then) =
      _$PaymentFormErrorsCopyWithImpl<$Res>;
}

/// @nodoc
class _$PaymentFormErrorsCopyWithImpl<$Res>
    implements $PaymentFormErrorsCopyWith<$Res> {
  _$PaymentFormErrorsCopyWithImpl(this._value, this._then);

  final PaymentFormErrors _value;
  // ignore: unused_field
  final $Res Function(PaymentFormErrors) _then;
}

/// @nodoc
abstract class $UnexpectedCopyWith<$Res> {
  factory $UnexpectedCopyWith(
          Unexpected value, $Res Function(Unexpected) then) =
      _$UnexpectedCopyWithImpl<$Res>;
}

/// @nodoc
class _$UnexpectedCopyWithImpl<$Res>
    extends _$PaymentFormErrorsCopyWithImpl<$Res>
    implements $UnexpectedCopyWith<$Res> {
  _$UnexpectedCopyWithImpl(Unexpected _value, $Res Function(Unexpected) _then)
      : super(_value, (v) => _then(v as Unexpected));

  @override
  Unexpected get _value => super._value as Unexpected;
}

/// @nodoc
class _$Unexpected implements Unexpected {
  const _$Unexpected();

  @override
  String toString() {
    return 'PaymentFormErrors.unexpected()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Unexpected);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unexpected(),
    @required TResult errorMakingPayment(),
    @required TResult cancelled(),
  }) {
    assert(unexpected != null);
    assert(errorMakingPayment != null);
    assert(cancelled != null);
    return unexpected();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unexpected(),
    TResult errorMakingPayment(),
    TResult cancelled(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (unexpected != null) {
      return unexpected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unexpected(Unexpected value),
    @required TResult errorMakingPayment(ErrorMakingPayment value),
    @required TResult cancelled(Cancelled value),
  }) {
    assert(unexpected != null);
    assert(errorMakingPayment != null);
    assert(cancelled != null);
    return unexpected(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unexpected(Unexpected value),
    TResult errorMakingPayment(ErrorMakingPayment value),
    TResult cancelled(Cancelled value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (unexpected != null) {
      return unexpected(this);
    }
    return orElse();
  }
}

abstract class Unexpected implements PaymentFormErrors {
  const factory Unexpected() = _$Unexpected;
}

/// @nodoc
abstract class $ErrorMakingPaymentCopyWith<$Res> {
  factory $ErrorMakingPaymentCopyWith(
          ErrorMakingPayment value, $Res Function(ErrorMakingPayment) then) =
      _$ErrorMakingPaymentCopyWithImpl<$Res>;
}

/// @nodoc
class _$ErrorMakingPaymentCopyWithImpl<$Res>
    extends _$PaymentFormErrorsCopyWithImpl<$Res>
    implements $ErrorMakingPaymentCopyWith<$Res> {
  _$ErrorMakingPaymentCopyWithImpl(
      ErrorMakingPayment _value, $Res Function(ErrorMakingPayment) _then)
      : super(_value, (v) => _then(v as ErrorMakingPayment));

  @override
  ErrorMakingPayment get _value => super._value as ErrorMakingPayment;
}

/// @nodoc
class _$ErrorMakingPayment implements ErrorMakingPayment {
  const _$ErrorMakingPayment();

  @override
  String toString() {
    return 'PaymentFormErrors.errorMakingPayment()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ErrorMakingPayment);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unexpected(),
    @required TResult errorMakingPayment(),
    @required TResult cancelled(),
  }) {
    assert(unexpected != null);
    assert(errorMakingPayment != null);
    assert(cancelled != null);
    return errorMakingPayment();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unexpected(),
    TResult errorMakingPayment(),
    TResult cancelled(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (errorMakingPayment != null) {
      return errorMakingPayment();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unexpected(Unexpected value),
    @required TResult errorMakingPayment(ErrorMakingPayment value),
    @required TResult cancelled(Cancelled value),
  }) {
    assert(unexpected != null);
    assert(errorMakingPayment != null);
    assert(cancelled != null);
    return errorMakingPayment(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unexpected(Unexpected value),
    TResult errorMakingPayment(ErrorMakingPayment value),
    TResult cancelled(Cancelled value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (errorMakingPayment != null) {
      return errorMakingPayment(this);
    }
    return orElse();
  }
}

abstract class ErrorMakingPayment implements PaymentFormErrors {
  const factory ErrorMakingPayment() = _$ErrorMakingPayment;
}

/// @nodoc
abstract class $CancelledCopyWith<$Res> {
  factory $CancelledCopyWith(Cancelled value, $Res Function(Cancelled) then) =
      _$CancelledCopyWithImpl<$Res>;
}

/// @nodoc
class _$CancelledCopyWithImpl<$Res>
    extends _$PaymentFormErrorsCopyWithImpl<$Res>
    implements $CancelledCopyWith<$Res> {
  _$CancelledCopyWithImpl(Cancelled _value, $Res Function(Cancelled) _then)
      : super(_value, (v) => _then(v as Cancelled));

  @override
  Cancelled get _value => super._value as Cancelled;
}

/// @nodoc
class _$Cancelled implements Cancelled {
  const _$Cancelled();

  @override
  String toString() {
    return 'PaymentFormErrors.cancelled()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Cancelled);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unexpected(),
    @required TResult errorMakingPayment(),
    @required TResult cancelled(),
  }) {
    assert(unexpected != null);
    assert(errorMakingPayment != null);
    assert(cancelled != null);
    return cancelled();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unexpected(),
    TResult errorMakingPayment(),
    TResult cancelled(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (cancelled != null) {
      return cancelled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unexpected(Unexpected value),
    @required TResult errorMakingPayment(ErrorMakingPayment value),
    @required TResult cancelled(Cancelled value),
  }) {
    assert(unexpected != null);
    assert(errorMakingPayment != null);
    assert(cancelled != null);
    return cancelled(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unexpected(Unexpected value),
    TResult errorMakingPayment(ErrorMakingPayment value),
    TResult cancelled(Cancelled value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (cancelled != null) {
      return cancelled(this);
    }
    return orElse();
  }
}

abstract class Cancelled implements PaymentFormErrors {
  const factory Cancelled() = _$Cancelled;
}
