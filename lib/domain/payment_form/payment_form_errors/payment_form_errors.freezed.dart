// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'payment_form_errors.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$PaymentFormErrorsTearOff {
  const _$PaymentFormErrorsTearOff();

// ignore: unused_element
  Unexpected unexpected() {
    return const Unexpected();
  }

// ignore: unused_element
  ErrorMakingPayment errorMakingPayment() {
    return const ErrorMakingPayment();
  }

// ignore: unused_element
  Cancelled cancelled() {
    return const Cancelled();
  }

// ignore: unused_element
  InvalidPersonalInformation invalidPersonalInformation() {
    return const InvalidPersonalInformation();
  }

// ignore: unused_element
  InvalidAddressInformation invalidAddressInformation() {
    return const InvalidAddressInformation();
  }

// ignore: unused_element
  ErrorFindingAddress errorFindingAddress() {
    return const ErrorFindingAddress();
  }
}

/// @nodoc
// ignore: unused_element
const $PaymentFormErrors = _$PaymentFormErrorsTearOff();

/// @nodoc
mixin _$PaymentFormErrors {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unexpected(),
    @required TResult errorMakingPayment(),
    @required TResult cancelled(),
    @required TResult invalidPersonalInformation(),
    @required TResult invalidAddressInformation(),
    @required TResult errorFindingAddress(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unexpected(),
    TResult errorMakingPayment(),
    TResult cancelled(),
    TResult invalidPersonalInformation(),
    TResult invalidAddressInformation(),
    TResult errorFindingAddress(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unexpected(Unexpected value),
    @required TResult errorMakingPayment(ErrorMakingPayment value),
    @required TResult cancelled(Cancelled value),
    @required
        TResult invalidPersonalInformation(InvalidPersonalInformation value),
    @required
        TResult invalidAddressInformation(InvalidAddressInformation value),
    @required TResult errorFindingAddress(ErrorFindingAddress value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unexpected(Unexpected value),
    TResult errorMakingPayment(ErrorMakingPayment value),
    TResult cancelled(Cancelled value),
    TResult invalidPersonalInformation(InvalidPersonalInformation value),
    TResult invalidAddressInformation(InvalidAddressInformation value),
    TResult errorFindingAddress(ErrorFindingAddress value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $PaymentFormErrorsCopyWith<$Res> {
  factory $PaymentFormErrorsCopyWith(
          PaymentFormErrors value, $Res Function(PaymentFormErrors) then) =
      _$PaymentFormErrorsCopyWithImpl<$Res>;
}

/// @nodoc
class _$PaymentFormErrorsCopyWithImpl<$Res>
    implements $PaymentFormErrorsCopyWith<$Res> {
  _$PaymentFormErrorsCopyWithImpl(this._value, this._then);

  final PaymentFormErrors _value;
  // ignore: unused_field
  final $Res Function(PaymentFormErrors) _then;
}

/// @nodoc
abstract class $UnexpectedCopyWith<$Res> {
  factory $UnexpectedCopyWith(
          Unexpected value, $Res Function(Unexpected) then) =
      _$UnexpectedCopyWithImpl<$Res>;
}

/// @nodoc
class _$UnexpectedCopyWithImpl<$Res>
    extends _$PaymentFormErrorsCopyWithImpl<$Res>
    implements $UnexpectedCopyWith<$Res> {
  _$UnexpectedCopyWithImpl(Unexpected _value, $Res Function(Unexpected) _then)
      : super(_value, (v) => _then(v as Unexpected));

  @override
  Unexpected get _value => super._value as Unexpected;
}

/// @nodoc
class _$Unexpected implements Unexpected {
  const _$Unexpected();

  @override
  String toString() {
    return 'PaymentFormErrors.unexpected()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Unexpected);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unexpected(),
    @required TResult errorMakingPayment(),
    @required TResult cancelled(),
    @required TResult invalidPersonalInformation(),
    @required TResult invalidAddressInformation(),
    @required TResult errorFindingAddress(),
  }) {
    assert(unexpected != null);
    assert(errorMakingPayment != null);
    assert(cancelled != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(errorFindingAddress != null);
    return unexpected();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unexpected(),
    TResult errorMakingPayment(),
    TResult cancelled(),
    TResult invalidPersonalInformation(),
    TResult invalidAddressInformation(),
    TResult errorFindingAddress(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (unexpected != null) {
      return unexpected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unexpected(Unexpected value),
    @required TResult errorMakingPayment(ErrorMakingPayment value),
    @required TResult cancelled(Cancelled value),
    @required
        TResult invalidPersonalInformation(InvalidPersonalInformation value),
    @required
        TResult invalidAddressInformation(InvalidAddressInformation value),
    @required TResult errorFindingAddress(ErrorFindingAddress value),
  }) {
    assert(unexpected != null);
    assert(errorMakingPayment != null);
    assert(cancelled != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(errorFindingAddress != null);
    return unexpected(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unexpected(Unexpected value),
    TResult errorMakingPayment(ErrorMakingPayment value),
    TResult cancelled(Cancelled value),
    TResult invalidPersonalInformation(InvalidPersonalInformation value),
    TResult invalidAddressInformation(InvalidAddressInformation value),
    TResult errorFindingAddress(ErrorFindingAddress value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (unexpected != null) {
      return unexpected(this);
    }
    return orElse();
  }
}

abstract class Unexpected implements PaymentFormErrors {
  const factory Unexpected() = _$Unexpected;
}

/// @nodoc
abstract class $ErrorMakingPaymentCopyWith<$Res> {
  factory $ErrorMakingPaymentCopyWith(
          ErrorMakingPayment value, $Res Function(ErrorMakingPayment) then) =
      _$ErrorMakingPaymentCopyWithImpl<$Res>;
}

/// @nodoc
class _$ErrorMakingPaymentCopyWithImpl<$Res>
    extends _$PaymentFormErrorsCopyWithImpl<$Res>
    implements $ErrorMakingPaymentCopyWith<$Res> {
  _$ErrorMakingPaymentCopyWithImpl(
      ErrorMakingPayment _value, $Res Function(ErrorMakingPayment) _then)
      : super(_value, (v) => _then(v as ErrorMakingPayment));

  @override
  ErrorMakingPayment get _value => super._value as ErrorMakingPayment;
}

/// @nodoc
class _$ErrorMakingPayment implements ErrorMakingPayment {
  const _$ErrorMakingPayment();

  @override
  String toString() {
    return 'PaymentFormErrors.errorMakingPayment()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ErrorMakingPayment);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unexpected(),
    @required TResult errorMakingPayment(),
    @required TResult cancelled(),
    @required TResult invalidPersonalInformation(),
    @required TResult invalidAddressInformation(),
    @required TResult errorFindingAddress(),
  }) {
    assert(unexpected != null);
    assert(errorMakingPayment != null);
    assert(cancelled != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(errorFindingAddress != null);
    return errorMakingPayment();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unexpected(),
    TResult errorMakingPayment(),
    TResult cancelled(),
    TResult invalidPersonalInformation(),
    TResult invalidAddressInformation(),
    TResult errorFindingAddress(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (errorMakingPayment != null) {
      return errorMakingPayment();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unexpected(Unexpected value),
    @required TResult errorMakingPayment(ErrorMakingPayment value),
    @required TResult cancelled(Cancelled value),
    @required
        TResult invalidPersonalInformation(InvalidPersonalInformation value),
    @required
        TResult invalidAddressInformation(InvalidAddressInformation value),
    @required TResult errorFindingAddress(ErrorFindingAddress value),
  }) {
    assert(unexpected != null);
    assert(errorMakingPayment != null);
    assert(cancelled != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(errorFindingAddress != null);
    return errorMakingPayment(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unexpected(Unexpected value),
    TResult errorMakingPayment(ErrorMakingPayment value),
    TResult cancelled(Cancelled value),
    TResult invalidPersonalInformation(InvalidPersonalInformation value),
    TResult invalidAddressInformation(InvalidAddressInformation value),
    TResult errorFindingAddress(ErrorFindingAddress value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (errorMakingPayment != null) {
      return errorMakingPayment(this);
    }
    return orElse();
  }
}

abstract class ErrorMakingPayment implements PaymentFormErrors {
  const factory ErrorMakingPayment() = _$ErrorMakingPayment;
}

/// @nodoc
abstract class $CancelledCopyWith<$Res> {
  factory $CancelledCopyWith(Cancelled value, $Res Function(Cancelled) then) =
      _$CancelledCopyWithImpl<$Res>;
}

/// @nodoc
class _$CancelledCopyWithImpl<$Res>
    extends _$PaymentFormErrorsCopyWithImpl<$Res>
    implements $CancelledCopyWith<$Res> {
  _$CancelledCopyWithImpl(Cancelled _value, $Res Function(Cancelled) _then)
      : super(_value, (v) => _then(v as Cancelled));

  @override
  Cancelled get _value => super._value as Cancelled;
}

/// @nodoc
class _$Cancelled implements Cancelled {
  const _$Cancelled();

  @override
  String toString() {
    return 'PaymentFormErrors.cancelled()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Cancelled);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unexpected(),
    @required TResult errorMakingPayment(),
    @required TResult cancelled(),
    @required TResult invalidPersonalInformation(),
    @required TResult invalidAddressInformation(),
    @required TResult errorFindingAddress(),
  }) {
    assert(unexpected != null);
    assert(errorMakingPayment != null);
    assert(cancelled != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(errorFindingAddress != null);
    return cancelled();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unexpected(),
    TResult errorMakingPayment(),
    TResult cancelled(),
    TResult invalidPersonalInformation(),
    TResult invalidAddressInformation(),
    TResult errorFindingAddress(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (cancelled != null) {
      return cancelled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unexpected(Unexpected value),
    @required TResult errorMakingPayment(ErrorMakingPayment value),
    @required TResult cancelled(Cancelled value),
    @required
        TResult invalidPersonalInformation(InvalidPersonalInformation value),
    @required
        TResult invalidAddressInformation(InvalidAddressInformation value),
    @required TResult errorFindingAddress(ErrorFindingAddress value),
  }) {
    assert(unexpected != null);
    assert(errorMakingPayment != null);
    assert(cancelled != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(errorFindingAddress != null);
    return cancelled(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unexpected(Unexpected value),
    TResult errorMakingPayment(ErrorMakingPayment value),
    TResult cancelled(Cancelled value),
    TResult invalidPersonalInformation(InvalidPersonalInformation value),
    TResult invalidAddressInformation(InvalidAddressInformation value),
    TResult errorFindingAddress(ErrorFindingAddress value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (cancelled != null) {
      return cancelled(this);
    }
    return orElse();
  }
}

abstract class Cancelled implements PaymentFormErrors {
  const factory Cancelled() = _$Cancelled;
}

/// @nodoc
abstract class $InvalidPersonalInformationCopyWith<$Res> {
  factory $InvalidPersonalInformationCopyWith(InvalidPersonalInformation value,
          $Res Function(InvalidPersonalInformation) then) =
      _$InvalidPersonalInformationCopyWithImpl<$Res>;
}

/// @nodoc
class _$InvalidPersonalInformationCopyWithImpl<$Res>
    extends _$PaymentFormErrorsCopyWithImpl<$Res>
    implements $InvalidPersonalInformationCopyWith<$Res> {
  _$InvalidPersonalInformationCopyWithImpl(InvalidPersonalInformation _value,
      $Res Function(InvalidPersonalInformation) _then)
      : super(_value, (v) => _then(v as InvalidPersonalInformation));

  @override
  InvalidPersonalInformation get _value =>
      super._value as InvalidPersonalInformation;
}

/// @nodoc
class _$InvalidPersonalInformation implements InvalidPersonalInformation {
  const _$InvalidPersonalInformation();

  @override
  String toString() {
    return 'PaymentFormErrors.invalidPersonalInformation()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidPersonalInformation);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unexpected(),
    @required TResult errorMakingPayment(),
    @required TResult cancelled(),
    @required TResult invalidPersonalInformation(),
    @required TResult invalidAddressInformation(),
    @required TResult errorFindingAddress(),
  }) {
    assert(unexpected != null);
    assert(errorMakingPayment != null);
    assert(cancelled != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(errorFindingAddress != null);
    return invalidPersonalInformation();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unexpected(),
    TResult errorMakingPayment(),
    TResult cancelled(),
    TResult invalidPersonalInformation(),
    TResult invalidAddressInformation(),
    TResult errorFindingAddress(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidPersonalInformation != null) {
      return invalidPersonalInformation();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unexpected(Unexpected value),
    @required TResult errorMakingPayment(ErrorMakingPayment value),
    @required TResult cancelled(Cancelled value),
    @required
        TResult invalidPersonalInformation(InvalidPersonalInformation value),
    @required
        TResult invalidAddressInformation(InvalidAddressInformation value),
    @required TResult errorFindingAddress(ErrorFindingAddress value),
  }) {
    assert(unexpected != null);
    assert(errorMakingPayment != null);
    assert(cancelled != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(errorFindingAddress != null);
    return invalidPersonalInformation(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unexpected(Unexpected value),
    TResult errorMakingPayment(ErrorMakingPayment value),
    TResult cancelled(Cancelled value),
    TResult invalidPersonalInformation(InvalidPersonalInformation value),
    TResult invalidAddressInformation(InvalidAddressInformation value),
    TResult errorFindingAddress(ErrorFindingAddress value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidPersonalInformation != null) {
      return invalidPersonalInformation(this);
    }
    return orElse();
  }
}

abstract class InvalidPersonalInformation implements PaymentFormErrors {
  const factory InvalidPersonalInformation() = _$InvalidPersonalInformation;
}

/// @nodoc
abstract class $InvalidAddressInformationCopyWith<$Res> {
  factory $InvalidAddressInformationCopyWith(InvalidAddressInformation value,
          $Res Function(InvalidAddressInformation) then) =
      _$InvalidAddressInformationCopyWithImpl<$Res>;
}

/// @nodoc
class _$InvalidAddressInformationCopyWithImpl<$Res>
    extends _$PaymentFormErrorsCopyWithImpl<$Res>
    implements $InvalidAddressInformationCopyWith<$Res> {
  _$InvalidAddressInformationCopyWithImpl(InvalidAddressInformation _value,
      $Res Function(InvalidAddressInformation) _then)
      : super(_value, (v) => _then(v as InvalidAddressInformation));

  @override
  InvalidAddressInformation get _value =>
      super._value as InvalidAddressInformation;
}

/// @nodoc
class _$InvalidAddressInformation implements InvalidAddressInformation {
  const _$InvalidAddressInformation();

  @override
  String toString() {
    return 'PaymentFormErrors.invalidAddressInformation()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InvalidAddressInformation);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unexpected(),
    @required TResult errorMakingPayment(),
    @required TResult cancelled(),
    @required TResult invalidPersonalInformation(),
    @required TResult invalidAddressInformation(),
    @required TResult errorFindingAddress(),
  }) {
    assert(unexpected != null);
    assert(errorMakingPayment != null);
    assert(cancelled != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(errorFindingAddress != null);
    return invalidAddressInformation();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unexpected(),
    TResult errorMakingPayment(),
    TResult cancelled(),
    TResult invalidPersonalInformation(),
    TResult invalidAddressInformation(),
    TResult errorFindingAddress(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidAddressInformation != null) {
      return invalidAddressInformation();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unexpected(Unexpected value),
    @required TResult errorMakingPayment(ErrorMakingPayment value),
    @required TResult cancelled(Cancelled value),
    @required
        TResult invalidPersonalInformation(InvalidPersonalInformation value),
    @required
        TResult invalidAddressInformation(InvalidAddressInformation value),
    @required TResult errorFindingAddress(ErrorFindingAddress value),
  }) {
    assert(unexpected != null);
    assert(errorMakingPayment != null);
    assert(cancelled != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(errorFindingAddress != null);
    return invalidAddressInformation(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unexpected(Unexpected value),
    TResult errorMakingPayment(ErrorMakingPayment value),
    TResult cancelled(Cancelled value),
    TResult invalidPersonalInformation(InvalidPersonalInformation value),
    TResult invalidAddressInformation(InvalidAddressInformation value),
    TResult errorFindingAddress(ErrorFindingAddress value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidAddressInformation != null) {
      return invalidAddressInformation(this);
    }
    return orElse();
  }
}

abstract class InvalidAddressInformation implements PaymentFormErrors {
  const factory InvalidAddressInformation() = _$InvalidAddressInformation;
}

/// @nodoc
abstract class $ErrorFindingAddressCopyWith<$Res> {
  factory $ErrorFindingAddressCopyWith(
          ErrorFindingAddress value, $Res Function(ErrorFindingAddress) then) =
      _$ErrorFindingAddressCopyWithImpl<$Res>;
}

/// @nodoc
class _$ErrorFindingAddressCopyWithImpl<$Res>
    extends _$PaymentFormErrorsCopyWithImpl<$Res>
    implements $ErrorFindingAddressCopyWith<$Res> {
  _$ErrorFindingAddressCopyWithImpl(
      ErrorFindingAddress _value, $Res Function(ErrorFindingAddress) _then)
      : super(_value, (v) => _then(v as ErrorFindingAddress));

  @override
  ErrorFindingAddress get _value => super._value as ErrorFindingAddress;
}

/// @nodoc
class _$ErrorFindingAddress implements ErrorFindingAddress {
  const _$ErrorFindingAddress();

  @override
  String toString() {
    return 'PaymentFormErrors.errorFindingAddress()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ErrorFindingAddress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult unexpected(),
    @required TResult errorMakingPayment(),
    @required TResult cancelled(),
    @required TResult invalidPersonalInformation(),
    @required TResult invalidAddressInformation(),
    @required TResult errorFindingAddress(),
  }) {
    assert(unexpected != null);
    assert(errorMakingPayment != null);
    assert(cancelled != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(errorFindingAddress != null);
    return errorFindingAddress();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult unexpected(),
    TResult errorMakingPayment(),
    TResult cancelled(),
    TResult invalidPersonalInformation(),
    TResult invalidAddressInformation(),
    TResult errorFindingAddress(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (errorFindingAddress != null) {
      return errorFindingAddress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult unexpected(Unexpected value),
    @required TResult errorMakingPayment(ErrorMakingPayment value),
    @required TResult cancelled(Cancelled value),
    @required
        TResult invalidPersonalInformation(InvalidPersonalInformation value),
    @required
        TResult invalidAddressInformation(InvalidAddressInformation value),
    @required TResult errorFindingAddress(ErrorFindingAddress value),
  }) {
    assert(unexpected != null);
    assert(errorMakingPayment != null);
    assert(cancelled != null);
    assert(invalidPersonalInformation != null);
    assert(invalidAddressInformation != null);
    assert(errorFindingAddress != null);
    return errorFindingAddress(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult unexpected(Unexpected value),
    TResult errorMakingPayment(ErrorMakingPayment value),
    TResult cancelled(Cancelled value),
    TResult invalidPersonalInformation(InvalidPersonalInformation value),
    TResult invalidAddressInformation(InvalidAddressInformation value),
    TResult errorFindingAddress(ErrorFindingAddress value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (errorFindingAddress != null) {
      return errorFindingAddress(this);
    }
    return orElse();
  }
}

abstract class ErrorFindingAddress implements PaymentFormErrors {
  const factory ErrorFindingAddress() = _$ErrorFindingAddress;
}
