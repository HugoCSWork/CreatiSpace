// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'user_messaging_watcher_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$UserMessagingWatcherEventTearOff {
  const _$UserMessagingWatcherEventTearOff();

// ignore: unused_element
  _watchAllUserMessagingList watchAllUserMessagingList() {
    return const _watchAllUserMessagingList();
  }

// ignore: unused_element
  _UserMessagesRecievedReceived MessagingListReceived(
      Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages) {
    return _UserMessagesRecievedReceived(
      failureOrMessages,
    );
  }

// ignore: unused_element
  _watchAllUserFollowingList watchAllUserFollowingList() {
    return const _watchAllUserFollowingList();
  }

// ignore: unused_element
  _UserFollowingListReceived FollowingListReceived(
      Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages) {
    return _UserFollowingListReceived(
      failureOrMessages,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $UserMessagingWatcherEvent = _$UserMessagingWatcherEventTearOff();

/// @nodoc
mixin _$UserMessagingWatcherEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult watchAllUserMessagingList(),
    @required
        TResult MessagingListReceived(
            Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages),
    @required TResult watchAllUserFollowingList(),
    @required
        TResult FollowingListReceived(
            Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult watchAllUserMessagingList(),
    TResult MessagingListReceived(
        Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages),
    TResult watchAllUserFollowingList(),
    TResult FollowingListReceived(
        Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required
        TResult watchAllUserMessagingList(_watchAllUserMessagingList value),
    @required
        TResult MessagingListReceived(_UserMessagesRecievedReceived value),
    @required
        TResult watchAllUserFollowingList(_watchAllUserFollowingList value),
    @required TResult FollowingListReceived(_UserFollowingListReceived value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult watchAllUserMessagingList(_watchAllUserMessagingList value),
    TResult MessagingListReceived(_UserMessagesRecievedReceived value),
    TResult watchAllUserFollowingList(_watchAllUserFollowingList value),
    TResult FollowingListReceived(_UserFollowingListReceived value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $UserMessagingWatcherEventCopyWith<$Res> {
  factory $UserMessagingWatcherEventCopyWith(UserMessagingWatcherEvent value,
          $Res Function(UserMessagingWatcherEvent) then) =
      _$UserMessagingWatcherEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$UserMessagingWatcherEventCopyWithImpl<$Res>
    implements $UserMessagingWatcherEventCopyWith<$Res> {
  _$UserMessagingWatcherEventCopyWithImpl(this._value, this._then);

  final UserMessagingWatcherEvent _value;
  // ignore: unused_field
  final $Res Function(UserMessagingWatcherEvent) _then;
}

/// @nodoc
abstract class _$watchAllUserMessagingListCopyWith<$Res> {
  factory _$watchAllUserMessagingListCopyWith(_watchAllUserMessagingList value,
          $Res Function(_watchAllUserMessagingList) then) =
      __$watchAllUserMessagingListCopyWithImpl<$Res>;
}

/// @nodoc
class __$watchAllUserMessagingListCopyWithImpl<$Res>
    extends _$UserMessagingWatcherEventCopyWithImpl<$Res>
    implements _$watchAllUserMessagingListCopyWith<$Res> {
  __$watchAllUserMessagingListCopyWithImpl(_watchAllUserMessagingList _value,
      $Res Function(_watchAllUserMessagingList) _then)
      : super(_value, (v) => _then(v as _watchAllUserMessagingList));

  @override
  _watchAllUserMessagingList get _value =>
      super._value as _watchAllUserMessagingList;
}

/// @nodoc
class _$_watchAllUserMessagingList implements _watchAllUserMessagingList {
  const _$_watchAllUserMessagingList();

  @override
  String toString() {
    return 'UserMessagingWatcherEvent.watchAllUserMessagingList()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _watchAllUserMessagingList);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult watchAllUserMessagingList(),
    @required
        TResult MessagingListReceived(
            Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages),
    @required TResult watchAllUserFollowingList(),
    @required
        TResult FollowingListReceived(
            Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages),
  }) {
    assert(watchAllUserMessagingList != null);
    assert(MessagingListReceived != null);
    assert(watchAllUserFollowingList != null);
    assert(FollowingListReceived != null);
    return watchAllUserMessagingList();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult watchAllUserMessagingList(),
    TResult MessagingListReceived(
        Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages),
    TResult watchAllUserFollowingList(),
    TResult FollowingListReceived(
        Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (watchAllUserMessagingList != null) {
      return watchAllUserMessagingList();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required
        TResult watchAllUserMessagingList(_watchAllUserMessagingList value),
    @required
        TResult MessagingListReceived(_UserMessagesRecievedReceived value),
    @required
        TResult watchAllUserFollowingList(_watchAllUserFollowingList value),
    @required TResult FollowingListReceived(_UserFollowingListReceived value),
  }) {
    assert(watchAllUserMessagingList != null);
    assert(MessagingListReceived != null);
    assert(watchAllUserFollowingList != null);
    assert(FollowingListReceived != null);
    return watchAllUserMessagingList(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult watchAllUserMessagingList(_watchAllUserMessagingList value),
    TResult MessagingListReceived(_UserMessagesRecievedReceived value),
    TResult watchAllUserFollowingList(_watchAllUserFollowingList value),
    TResult FollowingListReceived(_UserFollowingListReceived value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (watchAllUserMessagingList != null) {
      return watchAllUserMessagingList(this);
    }
    return orElse();
  }
}

abstract class _watchAllUserMessagingList implements UserMessagingWatcherEvent {
  const factory _watchAllUserMessagingList() = _$_watchAllUserMessagingList;
}

/// @nodoc
abstract class _$UserMessagesRecievedReceivedCopyWith<$Res> {
  factory _$UserMessagesRecievedReceivedCopyWith(
          _UserMessagesRecievedReceived value,
          $Res Function(_UserMessagesRecievedReceived) then) =
      __$UserMessagesRecievedReceivedCopyWithImpl<$Res>;
  $Res call(
      {Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages});
}

/// @nodoc
class __$UserMessagesRecievedReceivedCopyWithImpl<$Res>
    extends _$UserMessagingWatcherEventCopyWithImpl<$Res>
    implements _$UserMessagesRecievedReceivedCopyWith<$Res> {
  __$UserMessagesRecievedReceivedCopyWithImpl(
      _UserMessagesRecievedReceived _value,
      $Res Function(_UserMessagesRecievedReceived) _then)
      : super(_value, (v) => _then(v as _UserMessagesRecievedReceived));

  @override
  _UserMessagesRecievedReceived get _value =>
      super._value as _UserMessagesRecievedReceived;

  @override
  $Res call({
    Object failureOrMessages = freezed,
  }) {
    return _then(_UserMessagesRecievedReceived(
      failureOrMessages == freezed
          ? _value.failureOrMessages
          : failureOrMessages
              as Either<UserErrorFailure, KtList<UserMessaging>>,
    ));
  }
}

/// @nodoc
class _$_UserMessagesRecievedReceived implements _UserMessagesRecievedReceived {
  const _$_UserMessagesRecievedReceived(this.failureOrMessages)
      : assert(failureOrMessages != null);

  @override
  final Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages;

  @override
  String toString() {
    return 'UserMessagingWatcherEvent.MessagingListReceived(failureOrMessages: $failureOrMessages)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _UserMessagesRecievedReceived &&
            (identical(other.failureOrMessages, failureOrMessages) ||
                const DeepCollectionEquality()
                    .equals(other.failureOrMessages, failureOrMessages)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(failureOrMessages);

  @override
  _$UserMessagesRecievedReceivedCopyWith<_UserMessagesRecievedReceived>
      get copyWith => __$UserMessagesRecievedReceivedCopyWithImpl<
          _UserMessagesRecievedReceived>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult watchAllUserMessagingList(),
    @required
        TResult MessagingListReceived(
            Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages),
    @required TResult watchAllUserFollowingList(),
    @required
        TResult FollowingListReceived(
            Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages),
  }) {
    assert(watchAllUserMessagingList != null);
    assert(MessagingListReceived != null);
    assert(watchAllUserFollowingList != null);
    assert(FollowingListReceived != null);
    return MessagingListReceived(failureOrMessages);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult watchAllUserMessagingList(),
    TResult MessagingListReceived(
        Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages),
    TResult watchAllUserFollowingList(),
    TResult FollowingListReceived(
        Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (MessagingListReceived != null) {
      return MessagingListReceived(failureOrMessages);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required
        TResult watchAllUserMessagingList(_watchAllUserMessagingList value),
    @required
        TResult MessagingListReceived(_UserMessagesRecievedReceived value),
    @required
        TResult watchAllUserFollowingList(_watchAllUserFollowingList value),
    @required TResult FollowingListReceived(_UserFollowingListReceived value),
  }) {
    assert(watchAllUserMessagingList != null);
    assert(MessagingListReceived != null);
    assert(watchAllUserFollowingList != null);
    assert(FollowingListReceived != null);
    return MessagingListReceived(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult watchAllUserMessagingList(_watchAllUserMessagingList value),
    TResult MessagingListReceived(_UserMessagesRecievedReceived value),
    TResult watchAllUserFollowingList(_watchAllUserFollowingList value),
    TResult FollowingListReceived(_UserFollowingListReceived value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (MessagingListReceived != null) {
      return MessagingListReceived(this);
    }
    return orElse();
  }
}

abstract class _UserMessagesRecievedReceived
    implements UserMessagingWatcherEvent {
  const factory _UserMessagesRecievedReceived(
          Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages) =
      _$_UserMessagesRecievedReceived;

  Either<UserErrorFailure, KtList<UserMessaging>> get failureOrMessages;
  _$UserMessagesRecievedReceivedCopyWith<_UserMessagesRecievedReceived>
      get copyWith;
}

/// @nodoc
abstract class _$watchAllUserFollowingListCopyWith<$Res> {
  factory _$watchAllUserFollowingListCopyWith(_watchAllUserFollowingList value,
          $Res Function(_watchAllUserFollowingList) then) =
      __$watchAllUserFollowingListCopyWithImpl<$Res>;
}

/// @nodoc
class __$watchAllUserFollowingListCopyWithImpl<$Res>
    extends _$UserMessagingWatcherEventCopyWithImpl<$Res>
    implements _$watchAllUserFollowingListCopyWith<$Res> {
  __$watchAllUserFollowingListCopyWithImpl(_watchAllUserFollowingList _value,
      $Res Function(_watchAllUserFollowingList) _then)
      : super(_value, (v) => _then(v as _watchAllUserFollowingList));

  @override
  _watchAllUserFollowingList get _value =>
      super._value as _watchAllUserFollowingList;
}

/// @nodoc
class _$_watchAllUserFollowingList implements _watchAllUserFollowingList {
  const _$_watchAllUserFollowingList();

  @override
  String toString() {
    return 'UserMessagingWatcherEvent.watchAllUserFollowingList()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _watchAllUserFollowingList);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult watchAllUserMessagingList(),
    @required
        TResult MessagingListReceived(
            Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages),
    @required TResult watchAllUserFollowingList(),
    @required
        TResult FollowingListReceived(
            Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages),
  }) {
    assert(watchAllUserMessagingList != null);
    assert(MessagingListReceived != null);
    assert(watchAllUserFollowingList != null);
    assert(FollowingListReceived != null);
    return watchAllUserFollowingList();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult watchAllUserMessagingList(),
    TResult MessagingListReceived(
        Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages),
    TResult watchAllUserFollowingList(),
    TResult FollowingListReceived(
        Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (watchAllUserFollowingList != null) {
      return watchAllUserFollowingList();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required
        TResult watchAllUserMessagingList(_watchAllUserMessagingList value),
    @required
        TResult MessagingListReceived(_UserMessagesRecievedReceived value),
    @required
        TResult watchAllUserFollowingList(_watchAllUserFollowingList value),
    @required TResult FollowingListReceived(_UserFollowingListReceived value),
  }) {
    assert(watchAllUserMessagingList != null);
    assert(MessagingListReceived != null);
    assert(watchAllUserFollowingList != null);
    assert(FollowingListReceived != null);
    return watchAllUserFollowingList(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult watchAllUserMessagingList(_watchAllUserMessagingList value),
    TResult MessagingListReceived(_UserMessagesRecievedReceived value),
    TResult watchAllUserFollowingList(_watchAllUserFollowingList value),
    TResult FollowingListReceived(_UserFollowingListReceived value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (watchAllUserFollowingList != null) {
      return watchAllUserFollowingList(this);
    }
    return orElse();
  }
}

abstract class _watchAllUserFollowingList implements UserMessagingWatcherEvent {
  const factory _watchAllUserFollowingList() = _$_watchAllUserFollowingList;
}

/// @nodoc
abstract class _$UserFollowingListReceivedCopyWith<$Res> {
  factory _$UserFollowingListReceivedCopyWith(_UserFollowingListReceived value,
          $Res Function(_UserFollowingListReceived) then) =
      __$UserFollowingListReceivedCopyWithImpl<$Res>;
  $Res call(
      {Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages});
}

/// @nodoc
class __$UserFollowingListReceivedCopyWithImpl<$Res>
    extends _$UserMessagingWatcherEventCopyWithImpl<$Res>
    implements _$UserFollowingListReceivedCopyWith<$Res> {
  __$UserFollowingListReceivedCopyWithImpl(_UserFollowingListReceived _value,
      $Res Function(_UserFollowingListReceived) _then)
      : super(_value, (v) => _then(v as _UserFollowingListReceived));

  @override
  _UserFollowingListReceived get _value =>
      super._value as _UserFollowingListReceived;

  @override
  $Res call({
    Object failureOrMessages = freezed,
  }) {
    return _then(_UserFollowingListReceived(
      failureOrMessages == freezed
          ? _value.failureOrMessages
          : failureOrMessages
              as Either<UserErrorFailure, KtList<UserMessaging>>,
    ));
  }
}

/// @nodoc
class _$_UserFollowingListReceived implements _UserFollowingListReceived {
  const _$_UserFollowingListReceived(this.failureOrMessages)
      : assert(failureOrMessages != null);

  @override
  final Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages;

  @override
  String toString() {
    return 'UserMessagingWatcherEvent.FollowingListReceived(failureOrMessages: $failureOrMessages)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _UserFollowingListReceived &&
            (identical(other.failureOrMessages, failureOrMessages) ||
                const DeepCollectionEquality()
                    .equals(other.failureOrMessages, failureOrMessages)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(failureOrMessages);

  @override
  _$UserFollowingListReceivedCopyWith<_UserFollowingListReceived>
      get copyWith =>
          __$UserFollowingListReceivedCopyWithImpl<_UserFollowingListReceived>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult watchAllUserMessagingList(),
    @required
        TResult MessagingListReceived(
            Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages),
    @required TResult watchAllUserFollowingList(),
    @required
        TResult FollowingListReceived(
            Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages),
  }) {
    assert(watchAllUserMessagingList != null);
    assert(MessagingListReceived != null);
    assert(watchAllUserFollowingList != null);
    assert(FollowingListReceived != null);
    return FollowingListReceived(failureOrMessages);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult watchAllUserMessagingList(),
    TResult MessagingListReceived(
        Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages),
    TResult watchAllUserFollowingList(),
    TResult FollowingListReceived(
        Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (FollowingListReceived != null) {
      return FollowingListReceived(failureOrMessages);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required
        TResult watchAllUserMessagingList(_watchAllUserMessagingList value),
    @required
        TResult MessagingListReceived(_UserMessagesRecievedReceived value),
    @required
        TResult watchAllUserFollowingList(_watchAllUserFollowingList value),
    @required TResult FollowingListReceived(_UserFollowingListReceived value),
  }) {
    assert(watchAllUserMessagingList != null);
    assert(MessagingListReceived != null);
    assert(watchAllUserFollowingList != null);
    assert(FollowingListReceived != null);
    return FollowingListReceived(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult watchAllUserMessagingList(_watchAllUserMessagingList value),
    TResult MessagingListReceived(_UserMessagesRecievedReceived value),
    TResult watchAllUserFollowingList(_watchAllUserFollowingList value),
    TResult FollowingListReceived(_UserFollowingListReceived value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (FollowingListReceived != null) {
      return FollowingListReceived(this);
    }
    return orElse();
  }
}

abstract class _UserFollowingListReceived implements UserMessagingWatcherEvent {
  const factory _UserFollowingListReceived(
          Either<UserErrorFailure, KtList<UserMessaging>> failureOrMessages) =
      _$_UserFollowingListReceived;

  Either<UserErrorFailure, KtList<UserMessaging>> get failureOrMessages;
  _$UserFollowingListReceivedCopyWith<_UserFollowingListReceived> get copyWith;
}

/// @nodoc
class _$UserMessagingWatcherStateTearOff {
  const _$UserMessagingWatcherStateTearOff();

// ignore: unused_element
  _Initial initial() {
    return const _Initial();
  }

// ignore: unused_element
  _LoadInProgress loadInProgress() {
    return const _LoadInProgress();
  }

// ignore: unused_element
  _LoadSuccess loadSuccess(KtList<UserMessaging> items) {
    return _LoadSuccess(
      items,
    );
  }

// ignore: unused_element
  _LoadFailure loadFailure(UserErrorFailure itemFailure) {
    return _LoadFailure(
      itemFailure,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $UserMessagingWatcherState = _$UserMessagingWatcherStateTearOff();

/// @nodoc
mixin _$UserMessagingWatcherState {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult loadInProgress(),
    @required TResult loadSuccess(KtList<UserMessaging> items),
    @required TResult loadFailure(UserErrorFailure itemFailure),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult loadInProgress(),
    TResult loadSuccess(KtList<UserMessaging> items),
    TResult loadFailure(UserErrorFailure itemFailure),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult loadInProgress(_LoadInProgress value),
    @required TResult loadSuccess(_LoadSuccess value),
    @required TResult loadFailure(_LoadFailure value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult loadInProgress(_LoadInProgress value),
    TResult loadSuccess(_LoadSuccess value),
    TResult loadFailure(_LoadFailure value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $UserMessagingWatcherStateCopyWith<$Res> {
  factory $UserMessagingWatcherStateCopyWith(UserMessagingWatcherState value,
          $Res Function(UserMessagingWatcherState) then) =
      _$UserMessagingWatcherStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$UserMessagingWatcherStateCopyWithImpl<$Res>
    implements $UserMessagingWatcherStateCopyWith<$Res> {
  _$UserMessagingWatcherStateCopyWithImpl(this._value, this._then);

  final UserMessagingWatcherState _value;
  // ignore: unused_field
  final $Res Function(UserMessagingWatcherState) _then;
}

/// @nodoc
abstract class _$InitialCopyWith<$Res> {
  factory _$InitialCopyWith(_Initial value, $Res Function(_Initial) then) =
      __$InitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$InitialCopyWithImpl<$Res>
    extends _$UserMessagingWatcherStateCopyWithImpl<$Res>
    implements _$InitialCopyWith<$Res> {
  __$InitialCopyWithImpl(_Initial _value, $Res Function(_Initial) _then)
      : super(_value, (v) => _then(v as _Initial));

  @override
  _Initial get _value => super._value as _Initial;
}

/// @nodoc
class _$_Initial implements _Initial {
  const _$_Initial();

  @override
  String toString() {
    return 'UserMessagingWatcherState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult loadInProgress(),
    @required TResult loadSuccess(KtList<UserMessaging> items),
    @required TResult loadFailure(UserErrorFailure itemFailure),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult loadInProgress(),
    TResult loadSuccess(KtList<UserMessaging> items),
    TResult loadFailure(UserErrorFailure itemFailure),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult loadInProgress(_LoadInProgress value),
    @required TResult loadSuccess(_LoadSuccess value),
    @required TResult loadFailure(_LoadFailure value),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult loadInProgress(_LoadInProgress value),
    TResult loadSuccess(_LoadSuccess value),
    TResult loadFailure(_LoadFailure value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements UserMessagingWatcherState {
  const factory _Initial() = _$_Initial;
}

/// @nodoc
abstract class _$LoadInProgressCopyWith<$Res> {
  factory _$LoadInProgressCopyWith(
          _LoadInProgress value, $Res Function(_LoadInProgress) then) =
      __$LoadInProgressCopyWithImpl<$Res>;
}

/// @nodoc
class __$LoadInProgressCopyWithImpl<$Res>
    extends _$UserMessagingWatcherStateCopyWithImpl<$Res>
    implements _$LoadInProgressCopyWith<$Res> {
  __$LoadInProgressCopyWithImpl(
      _LoadInProgress _value, $Res Function(_LoadInProgress) _then)
      : super(_value, (v) => _then(v as _LoadInProgress));

  @override
  _LoadInProgress get _value => super._value as _LoadInProgress;
}

/// @nodoc
class _$_LoadInProgress implements _LoadInProgress {
  const _$_LoadInProgress();

  @override
  String toString() {
    return 'UserMessagingWatcherState.loadInProgress()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _LoadInProgress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult loadInProgress(),
    @required TResult loadSuccess(KtList<UserMessaging> items),
    @required TResult loadFailure(UserErrorFailure itemFailure),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadInProgress();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult loadInProgress(),
    TResult loadSuccess(KtList<UserMessaging> items),
    TResult loadFailure(UserErrorFailure itemFailure),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loadInProgress != null) {
      return loadInProgress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult loadInProgress(_LoadInProgress value),
    @required TResult loadSuccess(_LoadSuccess value),
    @required TResult loadFailure(_LoadFailure value),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadInProgress(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult loadInProgress(_LoadInProgress value),
    TResult loadSuccess(_LoadSuccess value),
    TResult loadFailure(_LoadFailure value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loadInProgress != null) {
      return loadInProgress(this);
    }
    return orElse();
  }
}

abstract class _LoadInProgress implements UserMessagingWatcherState {
  const factory _LoadInProgress() = _$_LoadInProgress;
}

/// @nodoc
abstract class _$LoadSuccessCopyWith<$Res> {
  factory _$LoadSuccessCopyWith(
          _LoadSuccess value, $Res Function(_LoadSuccess) then) =
      __$LoadSuccessCopyWithImpl<$Res>;
  $Res call({KtList<UserMessaging> items});
}

/// @nodoc
class __$LoadSuccessCopyWithImpl<$Res>
    extends _$UserMessagingWatcherStateCopyWithImpl<$Res>
    implements _$LoadSuccessCopyWith<$Res> {
  __$LoadSuccessCopyWithImpl(
      _LoadSuccess _value, $Res Function(_LoadSuccess) _then)
      : super(_value, (v) => _then(v as _LoadSuccess));

  @override
  _LoadSuccess get _value => super._value as _LoadSuccess;

  @override
  $Res call({
    Object items = freezed,
  }) {
    return _then(_LoadSuccess(
      items == freezed ? _value.items : items as KtList<UserMessaging>,
    ));
  }
}

/// @nodoc
class _$_LoadSuccess implements _LoadSuccess {
  const _$_LoadSuccess(this.items) : assert(items != null);

  @override
  final KtList<UserMessaging> items;

  @override
  String toString() {
    return 'UserMessagingWatcherState.loadSuccess(items: $items)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _LoadSuccess &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(items);

  @override
  _$LoadSuccessCopyWith<_LoadSuccess> get copyWith =>
      __$LoadSuccessCopyWithImpl<_LoadSuccess>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult loadInProgress(),
    @required TResult loadSuccess(KtList<UserMessaging> items),
    @required TResult loadFailure(UserErrorFailure itemFailure),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadSuccess(items);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult loadInProgress(),
    TResult loadSuccess(KtList<UserMessaging> items),
    TResult loadFailure(UserErrorFailure itemFailure),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loadSuccess != null) {
      return loadSuccess(items);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult loadInProgress(_LoadInProgress value),
    @required TResult loadSuccess(_LoadSuccess value),
    @required TResult loadFailure(_LoadFailure value),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult loadInProgress(_LoadInProgress value),
    TResult loadSuccess(_LoadSuccess value),
    TResult loadFailure(_LoadFailure value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loadSuccess != null) {
      return loadSuccess(this);
    }
    return orElse();
  }
}

abstract class _LoadSuccess implements UserMessagingWatcherState {
  const factory _LoadSuccess(KtList<UserMessaging> items) = _$_LoadSuccess;

  KtList<UserMessaging> get items;
  _$LoadSuccessCopyWith<_LoadSuccess> get copyWith;
}

/// @nodoc
abstract class _$LoadFailureCopyWith<$Res> {
  factory _$LoadFailureCopyWith(
          _LoadFailure value, $Res Function(_LoadFailure) then) =
      __$LoadFailureCopyWithImpl<$Res>;
  $Res call({UserErrorFailure itemFailure});

  $UserErrorFailureCopyWith<$Res> get itemFailure;
}

/// @nodoc
class __$LoadFailureCopyWithImpl<$Res>
    extends _$UserMessagingWatcherStateCopyWithImpl<$Res>
    implements _$LoadFailureCopyWith<$Res> {
  __$LoadFailureCopyWithImpl(
      _LoadFailure _value, $Res Function(_LoadFailure) _then)
      : super(_value, (v) => _then(v as _LoadFailure));

  @override
  _LoadFailure get _value => super._value as _LoadFailure;

  @override
  $Res call({
    Object itemFailure = freezed,
  }) {
    return _then(_LoadFailure(
      itemFailure == freezed
          ? _value.itemFailure
          : itemFailure as UserErrorFailure,
    ));
  }

  @override
  $UserErrorFailureCopyWith<$Res> get itemFailure {
    if (_value.itemFailure == null) {
      return null;
    }
    return $UserErrorFailureCopyWith<$Res>(_value.itemFailure, (value) {
      return _then(_value.copyWith(itemFailure: value));
    });
  }
}

/// @nodoc
class _$_LoadFailure implements _LoadFailure {
  const _$_LoadFailure(this.itemFailure) : assert(itemFailure != null);

  @override
  final UserErrorFailure itemFailure;

  @override
  String toString() {
    return 'UserMessagingWatcherState.loadFailure(itemFailure: $itemFailure)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _LoadFailure &&
            (identical(other.itemFailure, itemFailure) ||
                const DeepCollectionEquality()
                    .equals(other.itemFailure, itemFailure)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(itemFailure);

  @override
  _$LoadFailureCopyWith<_LoadFailure> get copyWith =>
      __$LoadFailureCopyWithImpl<_LoadFailure>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
    @required TResult loadInProgress(),
    @required TResult loadSuccess(KtList<UserMessaging> items),
    @required TResult loadFailure(UserErrorFailure itemFailure),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadFailure(itemFailure);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    TResult loadInProgress(),
    TResult loadSuccess(KtList<UserMessaging> items),
    TResult loadFailure(UserErrorFailure itemFailure),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loadFailure != null) {
      return loadFailure(itemFailure);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_Initial value),
    @required TResult loadInProgress(_LoadInProgress value),
    @required TResult loadSuccess(_LoadSuccess value),
    @required TResult loadFailure(_LoadFailure value),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_Initial value),
    TResult loadInProgress(_LoadInProgress value),
    TResult loadSuccess(_LoadSuccess value),
    TResult loadFailure(_LoadFailure value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loadFailure != null) {
      return loadFailure(this);
    }
    return orElse();
  }
}

abstract class _LoadFailure implements UserMessagingWatcherState {
  const factory _LoadFailure(UserErrorFailure itemFailure) = _$_LoadFailure;

  UserErrorFailure get itemFailure;
  _$LoadFailureCopyWith<_LoadFailure> get copyWith;
}
